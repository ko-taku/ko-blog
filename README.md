# 2025년 1월 31일 - OT

- **OT**
    - **전반적인 채용시장**
    - **커리큘럼**
    - **어떠한 채용 전략을 가지고 있는지**
        - 개인의 매력을 향상시킨다.

## 마크다운 사용법

[마크다운 사용법 가이드](https://gist.github.com/ihoneymon/652be052a0727ad59601)

  


# 2025년 2월 3일 TIL

## 오늘 한 일

### 블록체인 기술의 시작과 매커니즘에 대해 알아보았다

- **블록체인**은 디지털 문서의 타임 스탬프를 보장하기 위한 아이디어에서 출발한 기술.
- **블록체인**은 데이터를 안전하게 보호하기 위해 **암호화 기술**을 사용한다. 그 중 **디지털 서명**과 **해시**가 주요 암호화 기술이다.

#### 디지털 서명
- 트랜잭션을 보낸 사람의 신원을 확인하고, 데이터가 변조되지 않았음을 보장.

#### 해시 함수
- 블록의 고유한 해시값을 계산하여, 블록의 내용이 변경되지 않았음을 확인한다.
- 해시값은 블록에 대한 **불변성**을 보장하는 중요한 역할을 한다.

### 블록체인의 매커니즘

- **블록체인**은 **블록**이라는 데이터 단위로 이루어져 있으며, 각 블록은 여러 정보를 담고 있고 주로 **트랜잭션** 정보를 포함한다.
- 각 블록의 정보 구성:
  - **트랜잭션 목록**: 이 블록에 기록된 트랜잭션 정보.
  - **타임스탬프**: 블록이 생성된 시간.
  - **이전 블록의 해시**: 해당 블록이 이전 블록과 연결될 수 있도록 하는 값.
  - **블록 해시**: 현재 블록을 고유하게 식별하는 암호화된 해시 값.

- 각 블록은 **이전 블록의 해시**를 포함하고 있어 이를 통해 블록들이 체인 형태로 연결된다.
- 이러한 방식으로 하나의 블록이 변경되면 연결된 **모든 블록의 해시**가 변경되어 **변경 사항을 추적**할 수 있다. 이를 통해 **불변성**을 유지할 수 있다.

### 실물화폐와 신용화폐, 암호화폐의 역사에 대해 배웠다

- **화폐**가 가지고 있는 특성과 기능이 **암호화폐**에 어떻게 적용되는지 배웠다.

#### 화폐의 특성:
- **휴대성**
- **가분성**
- **내구성**
- **동질성**
- **가치의 안정성**

#### 화폐의 기능:
- **교환매개체 기능**: 빠른 거래 방식에 아직은 적합하지 않음.
- **가치척도의 기능**: 가격 변동이 심해 어려움.
- **가치 저장 기능**: 디지털 자산 역할.

### 탈중앙화된 문화를 옹호하는 사회 운동이 시작된 일련의 과정을 배웠다

- **서브프라임 모기지**: 미국의 초저금리 경기부양책 이후 벌어진 금융위기.
- **양적완화**: 금융위기를 해결하기 위한 방안이지만 여러 부작용을 초래:
  - 자산 가격 버블
  - 인플레이션 위험
  - 부의 양극화 심화
  - 달러 가치 하락과 환율 문제
  - 금융 시스템 왜곡
  - 정책 의존성 증가
  - 국제적 불균형 확대
  
- **사이버펑크**: 개인의 프라이버시를 중요시 생각한 사람들이 만든 단체로, 탈중앙화된 문화를 옹호하는 사회 운동을 시작.

# 맥 환경 설정 작업

**Homebrew 설치**

Homebrew를 설치하려면 터미널에서 아래 명령어를 실행합니다:

/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"


## nvm 다운로드 및 설치 및 Node.js 설치

터미널에서 아래 명령어를 실행하여 `nvm`을 설치합니다:

curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash

nvm 설치 후 zsh: command not found: nvm 나왔을 때 환경변수 설정이 안되어 있어서 설정해줘야한다

터미널에서 source ~/.nvm/nvm.sh로 환경변수 설정 이후 진행

설치 후 nvm ls로 버전 확인

버전을 맞춰주는 작업 nvm install 16.20.2로 버전을 다운받음

nvm use 16.20.2로 원하는 버전으로 설정해준다

# 2025년 2월 4일 TIL

## 타임스탬프 해시 생성과정

1. **입력 데이터의 해시 생성**  
    - 입력 데이터를 해시 함수(예: SHA-256)에 통과시켜 고정된 길이의 해시 값을 생성합니다.

2. **타임스탬프 기관에 제출**  
    - 생성된 해시 값을 타임스탬프 기관에 제출합니다. 기관은 해당 해시 값에 타임스탬프를 추가하고, 디지털 서명을 통해 데이터를 인증합니다.

3. **타임스탬프와 서명 반환**  
    - 타임스탬프 기관은 타임스탬프와 서명이 포함된 결과를 사용자에게 반환합니다.

4. **데이터 검증**  
    - 나중에 데이터를 검증하려면, 사용자가 원본 데이터에서 해시 값을 다시 계산한 후, 기관이 제공한 해시 값을 비교합니다.  
    - 해시 값이 일치하면 데이터가 변조되지 않았음을 확인할 수 있습니다.

5. **체인 구조 (선택적)**  
    - 여러 타임스탬프를 체인 형태로 연결하여 이전 타임스탬프의 해시 값을 포함시킬 수도 있습니다.  
    - 이를 통해 데이터의 시간 순서와 무결성을 보장합니다.

---

## SHA-256 알고리즘 요약

1. **입력 데이터 처리**  
    - 입력된 데이터는 아스키 코드로 표현된 이진 데이터로 변환됩니다.  
    - 데이터는 512비트 블록 단위로 처리되며, 크기가 모자라면 패딩을 추가하여 512비트를 맞춥니다.
        - **패딩**: 데이터의 끝에 1비트를 추가하고, 이후 0비트로 채웁니다.
    - 마지막 블록에는 64비트 길이 정보가 추가되어 총 512비트를 맞추게 됩니다.

2. **초기 해시값**  
    - SHA-256은 8개의 32비트 초기 해시값을 사용합니다. 이 값은 상태 변수로, 입력 데이터의 블록들이 처리되는 동안 계속해서 갱신됩니다.

3. **메시지 블록 처리**  
    - 입력 데이터는 512비트 블록 단위로 처리됩니다. 각 블록은 32비트 단위로 나누어 16개의 워드로 시작합니다.
    - 이후 메시지 스케줄을 통해 16개의 워드를 기반으로 48개의 새로운 워드를 생성하여 총 64개의 워드가 됩니다.
        - 처음 16개 워드는 입력 데이터에서 직접 파생됩니다.
        - 이후 48개 워드는 입력 데이터와 관계 없는 값들로, 기존 워드들을 바탕으로 연산을 통해 생성됩니다.

4. **라운드 처리**  
    - SHA-256은 64번의 라운드로 이루어져 있으며, 각 라운드에서 상태 변수가 업데이트됩니다.
    - 상태 변수는 각 라운드마다 계산을 통해 계속 변화하고, 최종적으로 최종 해시값을 계산하는 데 사용됩니다.

5. **최종 해시값 생성**  
    - 64번의 라운드 처리가 끝난 후, 8개의 상태 변수 값 (H0 ~ H7)은 256비트의 최종 해시값으로 결합됩니다.

### 핵심 요약

- **패딩**을 통해 입력 데이터는 항상 512비트 블록으로 맞춰진다.
- 초기 **해시값**(8개의 32비트)으로 시작해, 64번의 라운드를 거쳐 최종적으로 **256비트 해시값**을 생성한다.
- **메시지 스케줄링**을 통해 64개의 워드가 생성되며, 각 라운드에서 상태 변수는 계속 갱신된다.
- **충돌 저항성과 보안성**을 높이는 방식으로 연산이 이루어진다.

---
## 비트코인 블록체인 주요 요소

1. **블록 해시**  
    - 블록 해시는 블록 간 연결성을 유지하고, 변경된 데이터를 탐지하는 역할을 합니다.

2. **작업 증명 (Proof of Work)**  
    - 비트코인 채굴자는 새로운 블록을 블록체인에 추가하기 위해 해시 퍼즐을 풀어야 합니다. 이 과정을 작업 증명이라고 하며, 네트워크의 보안성을 높입니다.

3. **트랜잭션 ID**  
    - 각 트랜잭션에는 트랜잭션 ID가 존재하며, 이는 트랜잭션의 변경 여부를 확인하고 무결성을 보장합니다.

4. **머클 트리**  
    - 머클 트리는 블록 내의 모든 트랜잭션을 요약하고, 데이터 검증 및 효율적인 검색을 가능하게 하는 중요한 기술입니다.

5. **비트코인 주소**  
    - 비트코인 주소는 비대칭키 암호화에서 공개키를 해싱하여 생성됩니다.

6. **디지털 서명**  
    - 디지털 서명은 트랜잭션의 무결성을 보장하고, 소유권을 증명하는 데 중요한 역할을 하며, 이 과정에서 해시 함수가 사용됩니다.

---

## 암호화 개념 및 블록체인에서의 활용

### 암호화와 복호화
- **암호화**: 원본 데이터를 비밀 키를 사용하여 암호문으로 변환.
- **복호화**: 암호화 과정에서 사용한 키로 암호문을 다시 평문으로 변환.

### 대칭키 암호화 (Symmetric Key Encryption)
- **대칭키 암호화**는 암호화 및 복호화에 동일한 키를 사용하는 방식입니다.
- 주로 파일 암호화, VPN, SSL/TLS 프로토콜에서 사용되며, 파일 전송이나 디지털 저장소 보호에서 중요한 역할을 합니다.
  
  **장점**
  - 상대적으로 빠르고 효율적.
  - 키가 안전하게 유지되면 매우 강력한 보안.

  **단점**
  - 동일한 키를 공유해야 하므로 안전하게 키를 교환하는 방법이 필요.

  **예시**
  - AES (파일 보호, 인터넷 뱅킹)
  - DES, RC4 (스트리밍, VPN)

### 비대칭키 암호화 (Asymmetric Key Encryption)
- **비대칭키 암호화**는 공개키와 개인키를 한 쌍으로 사용하는 방식입니다.
- 블록체인에서 사용되는 대부분의 암호화 방식.

  **과정**
  - 개인 키를 16진수 문자열로 변환한 뒤, **Base58Check 인코딩** 방식으로 변환하여 사용자가 쉽게 보관하고 관리할 수 있게 함.
  - **공개 키**는 개인 키로부터 생성되며, 공개 키에서 개인 키를 유추할 수는 없고, 개인 키에서 공개 키를 유추할 수 있음.
  - 공개 키는 다시 **SHA-256**과 **RIPEMD-160** 해싱을 거쳐 주소가 생성됩니다.

#### 공개 키로 암호화 (Public Key Encryption)
- **공개 키**로 암호화한 데이터는 해당 **개인 키**만으로 복호화 가능합니다.
- 이 방식은 데이터의 기밀성을 보장하며, 데이터 전송 중 도청되어도 개인 키를 소유한 사용자만 복호화할 수 있습니다.
  
  **예시**
  - **TLS/SSL**을 통한 보안 웹 통신 (HTTPS)
  - **SSH** (Secure Shell)
  - **암호화된 이메일** (PGP/GPG)
  - **클라우드 저장소**에서의 데이터 암호화

#### 개인 키로 암호화 (Private Key Encryption)
- **개인 키**로 암호화한 데이터는 공개 키를 통해 변경되었는지 여부를 확인할 수 있습니다.
- **디지털 서명**에서 사용되며, 데이터의 무결성과 송신자의 신원을 증명합니다.
  
  **예시**
  - **디지털 서명** (데이터의 무결성 및 송신자 인증)
  - **암호화폐** (거래의 인증 및 보안)
  - **전자서명** (계약서, 문서 서명)
  - **전자투표 시스템** (투표의 무결성 및 익명성 보장)

#### 블록체인에서의 공개키 및 개인키 활용
- **공개 키**
  - 블록체인 주소 생성에 사용.
  - 디지털 서명을 검증할 때 사용.
  
- **개인 키**
  - 트랜잭션 서명에 사용.
  - 블록체인 자산의 소유권을 증명.

---
## 디지털 서명

- **디지털 서명**은 개인 키로 생성되고, 공개 키로 검증할 수 있습니다. 이를 통해 데이터의 **무결성**과 **진위성**을 확인할 수 있습니다.
- **공개 키로 서명을 검증**할 때, 데이터 자체를 복호화하는 것은 아닙니다. 대신 해시 값만을 비교하여 검증합니다.

### 디지털 서명의 동작 방식
1. **해싱**: 원본 데이터를 해싱하여 고정된 길이의 해시 값을 생성합니다.
2. **서명**: 송신자의 **개인 키**를 사용하여 해시 값에 서명을 생성합니다. 서명은 암호화된 해시 값으로, 데이터의 무결성과 진위성을 보증합니다.
3. **검증**: 수신자는 송신자의 **공개 키**로 서명을 복호화하고, 원본 데이터를 알고 있기 때문에 원본 데이터를 해싱한 값과 복호화된 값을 비교하여 변조 여부를 확인합니다.

### 디지털 서명 시스템의 필요조건
- **알고리즘의 수준**
- **시스템 구현**
- **개인 키 보호**

### 타임스탬프에서의 디지털 서명 사용 목적
- 데이터의 **무결성**을 증명하고, 데이터의 **시간**을 인증하여 신뢰를 제공합니다.

### 비트코인에서 디지털 서명의 역할
- **트랜잭션 무결성**을 보장
- **소유권**을 증명
- **탈중앙화된 검증** (중앙 기관 없이 신뢰를 유지)
- **ECDSA**(타원 곡선 디지털 서명 알고리즘)를 사용하여 서명을 생성하고 검증
- **비트코인 주소**는 공개 키를 해싱하여 생성됩니다 (SHA-256 + RIPEMD-160)
- 디지털 서명은 **64바이트** 크기로 트랜잭션 데이터에 포함됩니다.

---
## OpenSSL을 이용한 ECC 개인 키와 공개 키 생성

OpenSSL의 ECC 함수를 사용하여 개인 키와 공개 키 쌍을 생성하는 방법을 CLI(Command Line Interface) 방식으로 설명합니다.

### 1. OpenSSL에서 지원되는 타원곡선 목록 확인
OpenSSL을 이용하여 지원되는 타원곡선 목록을 확인하려면 다음 명령어를 사용합니다.

```bash
% openssl ecparam -list_curves
```
이번에 사용할 타원곡선은 비트코인에서 사용하는 secp256k1입니다. 

### 2. 개인 키 생성
다음 명령어를 사용하여 secp256k1 타원곡선 기반의 개인 키를 생성합니다.

```bash
% openssl ecparam -name secp256k1 -genkey -noout -out privatekey.pem
```

### 3. 생성된 개인 키 확인
생성된 개인 키를 확인하려면 다음 명령어를 사용합니다.

```bash
% cat privatekey.pem
```

### 4. 공개 키 생성
개인 키로부터 공개 키를 생성하려면 다음 명령어를 사용합니다.

```bash
% openssl ec -in privatekey.pem -pubout -out pubkey.pem
```

### 5. 생성된 공개 키 확인
생성된 공개 키를 확인하려면 다음 명령어를 사용합니다.

```bash
% cat pubkey.pem
```

### 6. 개인 키의 상세 정보 출력
개인 키에 대한 상세 정보를 출력하려면 다음 명령어를 사용합니다.

```bash
% openssl ec -in privatekey.pem -text -noout
```

**출력 내용 설명**
read EC key: 입력된 키 파일이 타원 곡선 알고리즘에 적합한 키 파일임을 확인
Private-Key: (256 bit): 개인 키의 크기 (256 비트)
priv: 개인 키의 값
pub: 공개 키의 값. 공개 키는 개인 키와 타원 곡선의 기준점을 곱하여 계산됩니다.
공개 키의 형태:

첫 번째 바이트: 04 (비압축 공개 키를 나타냄)
나머지 값: x와 y 좌표를 16진수로 나열한 값

### 7. 공개 키의 상세 정보 출력
공개 키에 대한 상세 정보를 출력하려면 다음 명령어를 사용합니다.

```bash
% openssl ec -in pubkey.pem -pubin -text -noout
```

**참고**: 공개 키에서는 개인 키를 유추할 수 없습니다.

### 8. 공개 키로 개인 키를 유추할 수 없는 이유
개인 키에서 공개 키를 계산할 수 있지만, 공개 키에서 개인 키를 유추하는 것은 불가능합니다. 그 이유는 다음과 같습니다:

이산 로그 문제: 타원 곡선에서 특정 점을 기반으로 역연산을 하는 것이 매우 어렵기 때문입니다.
연산의 비대칭성: 공개 키에서 개인 키를 추출하는 계산은 매우 복잡하고 시간 복잡도가 높습니다.
타원 곡선의 높은 보안성: 타원 곡선 기반 암호화는 매우 높은 보안

---
# 2025년 2월 5일 TIL

## 비트코인 블록 구조

비트코인의 블록은 **블록 헤더**와 **블록 바디**로 구성됩니다.

### 블록 헤더

블록 헤더는 블록에 대한 **메타데이터**를 포함하며, 블록의 고유 식별자 역할을 합니다. 블록 헤더의 크기는 **80바이트**로 고정되어 있습니다.

#### 블록 헤더의 주요 구성 요소

1. **이전 블록 해시**  
   - 이전 블록의 해시 값으로, 블록 간 연결성을 제공하고 **체인을 형성**합니다.  
   - 블록체인의 무결성을 보장합니다.

2. **머클 루트**  
   - 블록에 포함된 모든 트랜잭션의 해시 값을 결합하여 생성된 트리의 **루트 해시 값**입니다.  
   - 이를 통해 블록 내 모든 트랜잭션이 변경되지 않았음을 증명할 수 있습니다.

3. **타임스탬프**  
   - 블록이 생성된 시간을 나타내며, **UNIX 타임스탬프** 형식으로 저장됩니다.  
   - **초 단위**로 기록됩니다.

4. **난이도 타겟**  
   - 현재 블록 생성의 난이도를 정의하는 값입니다.  
   - 네트워크의 작업 증명 목표를 설정합니다.

5. **논스 (Nonce)**  
   - **작업 증명(PoW)**에서 정답을 찾기 위해 반복적으로 변경되는 값입니다.  
   - 채굴자는 이 값을 변경하면서 올바른 블록 해시를 찾기 위해 시도합니다.

6. **버전**  
   - 블록이 사용하고 있는 비트코인 프로토콜의 버전 정보입니다.



### 블록 바디

블록 바디는 **트랜잭션 데이터**를 저장합니다. 트랜잭션은 **코인베이스 트랜잭션**과 **일반 트랜잭션**으로 구성됩니다.

1. **코인베이스 트랜잭션**  
   - 블록을 생성한 채굴자에게 보상이 지급되는 트랜잭션입니다.  
   - 이는 항상 블록의 첫 번째 트랜잭션으로 포함됩니다.

2. **일반 트랜잭션**  
   - 블록에 포함된 **비트코인 전송 기록**입니다.  
   - 트랜잭션의 개수는 네트워크의 사태와 트랜잭션 용량에 따라 달라집니다.



## 트랜잭션 데이터 구조

트랜잭션은 **입력(Input)**과 **출력(Output)**으로 구성됩니다.  
각각은 **비트코인 네트워크에서 자금 흐름을 관리**하는 데 중요한 역할을 합니다.



## 비트코인 블록 크기

- **블록헤더**: 고정 크기 **80바이트**
- **트랜잭션 데이터**: 나머지 공간을 차지하며, **1MB** 또는 **4MB**까지 처리할 수 있습니다 (SegWit 활성화 이후).



## 비트코인 블록체인의 트랜잭션 구조

비트코인 블록체인의 **트랜잭션 구조**는 **송금 요청을 기록하고 검증**하는 데 사용되는 데이터 구조입니다.  
이 구조를 통해 비트코인 네트워크의 트랜잭션이 안전하게 관리됩니다.

---
## 트랜잭션의 주요 구성 요소

### 1. 버전
- 트랜잭션의 형식을 정의하는 숫자 필드입니다.
- 현재 사용 중인 비트코인 버전은 1과 2이며, 향후 업데이트를 대비해 사용됩니다.
- **크기**: 4바이트

### 2. 입력
- 입력은 트랜잭션이 사용하는 **이전 트랜잭션의 출력(UTXO)**을 참조합니다.  
- 입력에는 송신자의 서명이 포함된 정보가 담깁니다.

#### UTXO (미사용된 트랜잭션의 출력)
- **UTXO**는 비트코인 자금 출처 관리의 핵심 요소로, 자금 출처 추적, 잔고 관리, 트랜잭션의 근거로 사용됩니다.

##### 구성 요소
- **a. 트랜잭션 해시**  
  - 현재 트랜잭션이 참조하는 이전 트랜잭션의 해시 값입니다.  
  - **크기**: 32바이트

- **b. 출력 인덱스**  
  - 참조하는 트랜잭션에서 어떤 출력을 사용하는지 나타냅니다. (0부터 시작하는 인덱스)  
  - 즉, 지출할 UTXO입니다.  
  - **크기**: 4바이트

- **c. 스크립트 길이**  
  - 잠금 해제 스크립트의 길이를 나타냅니다.  
  - **크기**: 가변

- **d. 스크립트 서명**  
  - 이전 트랜잭션 출력의 소유권을 증명하기 위한 서명과 공개키로 구성된 스크립트입니다.  
  - 공개키와 디지털 서명이 포함됩니다.

- **e. 시퀀스 번호**  
  - 트랜잭션이 취소되거나 수정될 가능성을 나타내는 필드로, 현재는 거의 사용되지 않습니다.  
  - **크기**: 4바이트

### 3. 출력
- 출력은 수신자에게 전달되는 비트코인의 정보를 포함합니다.  
- 한 트랜잭션은 여러 개의 출력을 가질 수 있습니다.

##### 구성 요소
- **a. 출력 금액**  
  - 해당 출력에 포함된 비트코인의 금액을 나타냅니다.  
  - **단위**: 사토시 (1 비트코인 = 10^8 사토시)  
  - **크기**: 8바이트

- **b. 스크립트 길이**  
  - 잠금 스크립트의 길이를 나타냅니다.  
  - **크기**: 가변

- **c. 잠금 스크립트**  
  - 비트코인을 잠금(수신자의 주소를 설정)하는 스크립트입니다.  
  - 일반적으로 **P2PKH** 스크립트 형식을 사용하며 수신자의 주소를 포함합니다.

### 4. 잠금 스크립트와 해제 스크립트 예시

#### P2PKH (Pay-to-PubKey-Hash) 형식
- **잠금 해제 스크립트 (ScriptSig)**: 입력에서 사용되며, 이전 트랜잭션 출력의 소유권을 증명하기 위해 사용됩니다.  
  - 예: `<Signature> <Public Key>`
  
- **잠금 스크립트 (ScriptPubKey)**: 출력에서 사용되며, 수신자에게 비트코인을 보낼 주소를 지정합니다.  
  - 예: `OP_DUP OP_HASH160 <Recipient's Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG`

### 5. 트랜잭션 카운터
- 트랜잭션에 포함된 **입력**과 **출력**의 개수를 기록합니다.  
- 각각 입력 개수와 출력 개수를 별도로 저장하며, 네트워크가 각 트랜잭션의 크기를 빠르게 파악할 수 있게 합니다.  
- **크기**: 가변 (1바이트 이상, 비트코인 직렬화와 규칙에 따라 달라짐)

### 6. 잠금 시간
- 해당 트랜잭션이 유효해지는 조건을 나타냅니다.  
- 특정 블록 높이 또는 타임스탬프가 설정될 수 있으며, 이 조건이 충족되어야 트랜잭션이 유효합니다.  
- **크기**: 4바이트

---

### 트랜잭션 흐름의 요약

1. **송신자**는 입력에서 이전 트랜잭션 출력을 참조합니다.
2. 해당 입력에 **개인 키로 디지털 서명을 생성**하여 서명 스크립트(ScriptSig)에 포함합니다.
3. 송신자는 비트코인을 보낼 **수신자의 주소를 출력에 지정**하며, 잠금 스크립트(ScriptPubKey)를 생성합니다.
4. **수신자**는 잠금 스크립트를 해제하기 위해 자신의 공개 키와 서명을 제공합니다.
5. 네트워크 노드는 **입력과 출력의 검증을 수행**하여 트랜잭션이 올바른지 확인합니다.

---
## UTXO (미사용 트랜잭션 출력)

### UTXO 개념
- **UTXO**는 **출력에서 미사용된 상태**인 트랜잭션을 말합니다.
- 비트코인 네트워크에서 사용자의 잔고와 트랜잭션을 추적하는 기본 단위입니다.
- 사용자가 보유한 비트코인의 총량은 해당 사용자가 소유한 **UTXO의 합계**로 계산됩니다.
- **트랜잭션 검증**: UTXO는 트랜잭션의 입력으로 참조되며, 이미 소비된 UTXO는 다시 사용할 수 없기 때문에 **이중 지불을 방지**합니다.

### UTXO 동작 방식

#### 생성
- 트랜잭션의 출력으로 새 UTXO가 생성됩니다.
- 이 출력은 비트코인 주소로 잠겨 있으며, 해당 주소의 소유자만이 이를 소비할 수 있습니다.

#### 소비
- 트랜잭션의 입력은 기존 UTXO를 참조하여 소비됩니다.
- 소비된 UTXO는 더 이상 유효하지 않으며, 새로운 UTXO가 생성됩니다.

### UTXO 구조

1. **금액**: 해당 UTXO에 저장된 비트코인의 양
2. **트랜잭션 스크립트**: 소유자 정보가 저장된 트랜잭션 스크립트 형태
3. **트랜잭션 ID**: 이 UTXO를 생성한 트랜잭션의 고유 식별자
4. **출력 인덱스**: 해당 트랜잭션에서 이 UTXO가 몇 번째 출력인지를 나타내는 번호

> **참고**: 채굴자에게 지급된 수수료는 독립된 UTXO로 생성되지 않고, 블록 보상의 일부로 **코인베이스 트랜잭션**에 포함됩니다. 이 코인베이스 트랜잭션은 블록을 채굴했을 때 처음에 한 번만 제공됩니다.

### UTXO와 트랜잭션의 관계

#### 트랜잭션 입력
- 기존 UTXO를 참조하여 해당 금액을 소비합니다.

#### 트랜잭션 출력
- 새로운 UTXO를 생성하여 수신자 또는 잔돈으로 보냅니다.

#### 이중 지불 방지
- 이미 소비된 UTXO는 다시 사용할 수 없으므로 동일 금액을 반복 사용하려는 시도를 방지합니다.

### UTXO의 저장 및 관리

#### 잔고 계산
- 사용자의 잔고는 그들이 보유한 모든 **잔돈 UTXO**의 합계로 계산됩니다.
- 비트코인 네트워크는 **계좌 방식**이 아니라 독립적인 **UTXO 목록**을 통해 잔고를 추적합니다.

#### UTXO 세트
- 네트워크 노드는 전체 네트워크의 사용되지 않은 출력 목록(UTXO 세트)을 유지합니다.
- 이 목록은 새로운 트랜잭션을 생성할 때 **입력으로 사용할 수 있는 UTXO**를 추적합니다.
- 트랜잭션 검증 시 참조된 UTXO의 유효성을 확인하는 데 사용됩니다.

#### 저장소 요구사항
- 시간이 지남에 따라 트랜잭션 수와 사용되지 않은 출력이 누적되어 UTXO 세트의 크기가 증가합니다.
- 이는 네트워크의 저장소와 처리 부담을 증가시키며, 각 노드는 최신 UTXO 세트를 유지하기 위해 **상당한 저장소**를 요구합니다.

### UTXO의 장점과 단점

#### 장점
1. **보안성**: UTXO는 이중 지불을 방지하고 네트워크 무결성을 보장합니다.
2. **병렬 처리 기능**: 서로 독립적인 UTXO를 사용하면 병렬로 트랜잭션을 처리할 수 있습니다. 이를 통해 트랜잭션 처리 속도가 빨라지고, 더 많은 사용자가 네트워크를 이용할 수 있습니다.

#### 단점
1. **복잡한 잔돈 관리**: 트랜잭션마다 잔돈 UTXO가 새로 생성되므로 UTXO 세트가 빠르게 증가할 수 있습니다.
2. **저장소 부담**: 전체 네트워크의 UTXO 데이터를 유지하는 데 **상당한 저장소**가 필요합니다.

#### UTXO 소비 시 스크립트 언어 사용
- UTXO를 소비하려면 스크립트 언어를 통해 트랜잭션의 유효성을 확인해야 합니다.

### UTXO 검증(연산자 사용)
- **소유권 검증**: `OP_CHECKSIG`와 `OP_HASH160`을 활용하여 소유자를 확인합니다.
- **출력 검증**: `OP_EQUAL`과 `OP_VERIFY`를 통해 출력 주소와 금액이 올바른지 확인합니다.
- **보안성 강화**: `OP_DUP`과 `OP_CHECKMULTISIG`로 다중 서명 및 공개 키 변조 방지를 강화합니다.
---
## 머클 루트

### 머클 트리

- **머클 트리(Merkle Tree)**는 여러 데이터에 대해 단계적으로 해시 함수를 적용하여 최종적으로 **머클 루트(Merkle Root)**라는 하나의 최상단 해시값을 생성하는 데이터 구조입니다.
- 구체적으로 블록체인의 각 **트랜잭션 데이터를 해싱한 값**들을 결합하여 부모 노드를 만들고, 이를 반복하여 **루트 노드**를 생성합니다.
- **목적**: 데이터의 무결성을 보장하고 위변조를 방지하기 위해 사용됩니다.

#### 머클 트리의 동작 과정

1. **트랜잭션 해싱**:
   - 블록에 포함된 각 트랜잭션의 해시값을 계산합니다.
   - 예를 들어, 트랜잭션 A와 트랜잭션 B의 해시값을 계산한 후 `H(A)`와 `H(B)`를 SHA-256 해싱합니다.
   - 각 해시값은 256비트 크기의 해시 값을 가집니다.
   
2. **결합**:
   - 두 해시값을 결합하면 512비트의 값이 됩니다. 
   - 이 512비트 값을 다시 SHA-256 해싱하여 **부모 노드**를 생성합니다.

3. **반복**:
   - 이러한 과정을 반복하여 트리의 최상단에 **머클 루트**를 도출합니다.

4. **머클 루트 생성**:
   - 모든 트랜잭션을 해싱하고 결합하여 마지막으로 최상단의 **머클 루트**가 생성됩니다.
   - 이 최상단의 해시값은 **블록 헤더**에 포함되어 블록의 고유성을 보장합니다.

#### 예시
- 트랜잭션 `H(A)`와 `H(B)`는 각각 SHA-256 해싱을 통해 256바이트의 해시값을 가지며, 이 두 값을 결합하여 다시 SHA-256 해싱을 진행합니다.
- 이 과정을 반복하여 **최상단 머클 루트**가 도출됩니다.

> **참고**: 패딩이 필요 없는 이유는 첫 번째 해싱에서 입력 크기에 따라 패딩이 추가될 수 있지만, 두 번째 해싱에서는 256바이트로 고정된 길이를 처리하기 때문에 패딩이 필요 없습니다.

### 머클 루트의 중요성

#### 블록 헤더
- **머클 루트**는 **블록 헤더**에 저장되며 블록체인 네트워크에서 작업 증명을 수행할 때 중요한 역할을 합니다.
- 블록의 무결성을 증명하고, 트랜잭션의 변경 여부를 빠르게 확인할 수 있도록 해줍니다.

#### 경량화된 노드
- **경량화된 노드(Light Client)**는 블록체인의 전체 데이터를 다운로드하지 않고, **머클 루트**를 사용해 특정 트랜잭션의 유효성을 검증할 수 있습니다.
- 이를 통해 저장소와 네트워크 대역폭을 절약하면서도, 블록체인의 데이터를 검증할 수 있습니다.

#### 보안과 투명성
- **트랜잭션 변경 시 머클 루트가 달라짐**: 블록 내에서 하나의 트랜잭션 값이 변경되면 머클 루트가 달라지고, 이로 인해 **블록 해시 값**이 변경됩니다.
- **블록체인의 연쇄 구조**: 각 블록은 이전 블록의 해시값을 포함하므로, 한 블록의 변경은 **연쇄적으로** 다른 블록의 해시 값도 변경하게 됩니다.
- **위변조 방지**: 트랜잭션을 악의적으로 변경하면 해당 트랜잭션으로 인해 머클 루트 값이 달라지고, 이로 인해 전체 블록체인의 무결성이 깨집니다.

### 블록체인의 무결성과 합의 매커니즘

- 블록체인은 **무결성**을 보장하기 위해 머클 루트를 사용하고, **51% 공격** 방어를 통해 **보안성**을 강화합니다.
  - **51% 공격**: 악의적인 노드가 변경된 체인을 네트워크에 전파하더라도, 네트워크 전체 노드의 **51% 이상**에 해당하는 컴퓨팅 파워를 확보하지 않는 한 이 체인은 유효하지 않은 것으로 간주됩니다.
  
### 결론
- **머클 트리**와 **머클 루트**는 블록체인에서 트랜잭션의 무결성을 보장하고, 데이터 위변조를 방지하는 중요한 역할을 합니다.  
- 또한, 경량화된 노드를 가능하게 하여 블록체인 네트워크의 효율성과 보안성을 높이는 중요한 기술입니다.
---
## 비트코인 코어 설치 및 테스트넷 노드 운용 실습

### 1. Homebrew 설치 및 버전 확인
Homebrew가 설치되어 있지 않다면 먼저 설치 후 버전을 확인합니다.

brew --version

### 2. Bitcoin Core 설치
Homebrew를 통해 Bitcoin Core를 설치합니다.

brew install bitcoin

objectivec

설치 후 비트코인 CLI 버전 확인:

bitcoin-cli --version

### 3. 비트코인 데이터 저장 디렉토리 생성
비트코인 데이터를 저장할 디렉토리를 생성하고 해당 디렉토리로 이동합니다.

mkdir bitcoin_data cd bitcoin_data

현재 디렉토리 경로를 확인 후 나온 경로를 메모에 복사해 둡니다.

pwd

### 4. 비트코인 설정 파일 생성 및 테스트넷 모드 설정
`bitcoin.conf` 파일을 생성하고 테스트넷 모드로 설정합니다.

vim bitcoin.conf

아래 내용을 입력한 후 저장합니다:

regtest=1 server=1 rpcuser=user rpcpassword=password datadir=(pwd 후 나온 경로를 붙여넣기) fallbackfee=0.0002

- `rpcuser`와 `rpcpassword`는 나중에 `bitcoin-cli`에서 인증에 사용됩니다.

### 5. 로컬 비트코인 네트워크 실행
새로운 터미널을 열고 로컬 비트코인 네트워크를 실행합니다.

bitcoind -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf

### 6. 블록체인 동기화 확인
기존 터미널에서 실행을 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getblockchaininfo

출력 결과에 `"chain": "regtest"`가 포함되어 있어야 합니다.

- `"blocks"`: 노드가 블록체인에서 다운로드 받은 블록 수
- `"headers"`: 네트워크에서 사용 가능한 최신 블록 헤더 수
- `"verificationprogress"`: 네트워크와 동기화 진행률
예: `"verificationprogress": 0.0001` → 동기화 초기 단계.
예: `"verificationprogress": 1` → 동기화 완료.

### 7. 테스트넷용 지갑 주소 생성
테스트넷용 지갑 주소를 생성합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf createwallet "(이름)"

### 8. 지갑 주소 확인
생성된 지갑 주소를 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getnewaddress

생성된 지갑 주소는 다른 곳에 복사해 놓습니다.

### 9. 지갑 잔액 확인
생성된 비트코인 지갑의 잔액을 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getbalance

### 10. 블록 채굴
채굴 명령어를 실행하여 블록을 생성합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf generatetoaddress 101 (복사한 지갑 주소)

101은 생성할 블록 수입니다. `101`개의 블록을 채굴해야 하는 이유는 비트코인 프로토콜에서 새로 생성된 코인을 바로 사용할 수 없도록 제한하기 때문입니다. 이는 체인 리오르그를 방지하고 네트워크 안정성을 높이는 역할을 합니다.

### 11. 블록 생성 후 잔액 확인
블록 생성 후 잔액을 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getbalance

### 12. 사용 가능한 UTXO 확인
사용 가능한 UTXO를 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf listunspent

### 13. 송금용 지갑 주소 생성
송금용 지갑 주소를 생성합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getnewaddress

내 주소들을 확인하려면 다음 명령어를 사용합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf listreceivedbyaddress 0 true

### 14. 비트코인 송금
새로 생성한 주소로 비트코인을 송금합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf sendtoaddress <받는 주소> <금액>

### 15. 트랜잭션 상태 확인
트랜잭션 상태를 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf gettransaction (트랜잭션 ID)

### 16. 트랜잭션 확정을 위해 블록 생성
트랜잭션 확정을 위해 추가 블록을 생성합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf generatetoaddress 10 (지갑 주소)

### 17. 트랜잭션 상태 재확인
블록 생성 후 트랜잭션 상태를 다시 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf gettransaction (트랜잭션 ID)

### 18. 마지막으로 지갑 잔고 확인
내 지갑 잔고를 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf listreceivedbyaddress 0 true

- `listreceivedbyaddress` 명령어는 특정 주소가 받은 비트코인의 총합을 표시하며, 입금된 코인의 총합만 보여주고 출금된 코인은 포함되지 않습니다.
- 출금된 트랜잭션을 확인하려면 `listtransactions` 명령어를 사용해야 합니다.
