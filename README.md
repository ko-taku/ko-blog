# 2025년 1월 31일 - OT

- **OT**
    - **전반적인 채용시장**
    - **커리큘럼**
    - **어떠한 채용 전략을 가지고 있는지**
        - 개인의 매력을 향상시킨다.

## 마크다운 사용법

[마크다운 사용법 가이드](https://gist.github.com/ihoneymon/652be052a0727ad59601)

  


# 2025년 2월 3일 TIL

## 오늘 한 일

### 블록체인 기술의 시작과 매커니즘에 대해 알아보았다

- **블록체인**은 디지털 문서의 타임 스탬프를 보장하기 위한 아이디어에서 출발한 기술.
- **블록체인**은 데이터를 안전하게 보호하기 위해 **암호화 기술**을 사용한다. 그 중 **디지털 서명**과 **해시**가 주요 암호화 기술이다.

#### 디지털 서명
- 트랜잭션을 보낸 사람의 신원을 확인하고, 데이터가 변조되지 않았음을 보장.

#### 해시 함수
- 블록의 고유한 해시값을 계산하여, 블록의 내용이 변경되지 않았음을 확인한다.
- 해시값은 블록에 대한 **불변성**을 보장하는 중요한 역할을 한다.

### 블록체인의 매커니즘

- **블록체인**은 **블록**이라는 데이터 단위로 이루어져 있으며, 각 블록은 여러 정보를 담고 있고 주로 **트랜잭션** 정보를 포함한다.
- 각 블록의 정보 구성:
  - **트랜잭션 목록**: 이 블록에 기록된 트랜잭션 정보.
  - **타임스탬프**: 블록이 생성된 시간.
  - **이전 블록의 해시**: 해당 블록이 이전 블록과 연결될 수 있도록 하는 값.
  - **블록 해시**: 현재 블록을 고유하게 식별하는 암호화된 해시 값.

- 각 블록은 **이전 블록의 해시**를 포함하고 있어 이를 통해 블록들이 체인 형태로 연결된다.
- 이러한 방식으로 하나의 블록이 변경되면 연결된 **모든 블록의 해시**가 변경되어 **변경 사항을 추적**할 수 있다. 이를 통해 **불변성**을 유지할 수 있다.

### 실물화폐와 신용화폐, 암호화폐의 역사에 대해 배웠다

- **화폐**가 가지고 있는 특성과 기능이 **암호화폐**에 어떻게 적용되는지 배웠다.

#### 화폐의 특성:
- **휴대성**
- **가분성**
- **내구성**
- **동질성**
- **가치의 안정성**

#### 화폐의 기능:
- **교환매개체 기능**: 빠른 거래 방식에 아직은 적합하지 않음.
- **가치척도의 기능**: 가격 변동이 심해 어려움.
- **가치 저장 기능**: 디지털 자산 역할.

### 탈중앙화된 문화를 옹호하는 사회 운동이 시작된 일련의 과정을 배웠다

- **서브프라임 모기지**: 미국의 초저금리 경기부양책 이후 벌어진 금융위기.
- **양적완화**: 금융위기를 해결하기 위한 방안이지만 여러 부작용을 초래:
  - 자산 가격 버블
  - 인플레이션 위험
  - 부의 양극화 심화
  - 달러 가치 하락과 환율 문제
  - 금융 시스템 왜곡
  - 정책 의존성 증가
  - 국제적 불균형 확대
  
- **사이버펑크**: 개인의 프라이버시를 중요시 생각한 사람들이 만든 단체로, 탈중앙화된 문화를 옹호하는 사회 운동을 시작.

# 맥 환경 설정 작업

**Homebrew 설치**

Homebrew를 설치하려면 터미널에서 아래 명령어를 실행합니다:

/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"


## nvm 다운로드 및 설치 및 Node.js 설치

터미널에서 아래 명령어를 실행하여 `nvm`을 설치합니다:

curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash

nvm 설치 후 zsh: command not found: nvm 나왔을 때 환경변수 설정이 안되어 있어서 설정해줘야한다

터미널에서 source ~/.nvm/nvm.sh로 환경변수 설정 이후 진행

설치 후 nvm ls로 버전 확인

버전을 맞춰주는 작업 nvm install 16.20.2로 버전을 다운받음

nvm use 16.20.2로 원하는 버전으로 설정해준다

# 2025년 2월 4일 TIL

## 타임스탬프 해시 생성과정

1. **입력 데이터의 해시 생성**  
    - 입력 데이터를 해시 함수(예: SHA-256)에 통과시켜 고정된 길이의 해시 값을 생성합니다.

2. **타임스탬프 기관에 제출**  
    - 생성된 해시 값을 타임스탬프 기관에 제출합니다. 기관은 해당 해시 값에 타임스탬프를 추가하고, 디지털 서명을 통해 데이터를 인증합니다.

3. **타임스탬프와 서명 반환**  
    - 타임스탬프 기관은 타임스탬프와 서명이 포함된 결과를 사용자에게 반환합니다.

4. **데이터 검증**  
    - 나중에 데이터를 검증하려면, 사용자가 원본 데이터에서 해시 값을 다시 계산한 후, 기관이 제공한 해시 값을 비교합니다.  
    - 해시 값이 일치하면 데이터가 변조되지 않았음을 확인할 수 있습니다.

5. **체인 구조 (선택적)**  
    - 여러 타임스탬프를 체인 형태로 연결하여 이전 타임스탬프의 해시 값을 포함시킬 수도 있습니다.  
    - 이를 통해 데이터의 시간 순서와 무결성을 보장합니다.

---

## SHA-256 알고리즘 요약

1. **입력 데이터 처리**  
    - 입력된 데이터는 아스키 코드로 표현된 이진 데이터로 변환됩니다.  
    - 데이터는 512비트 블록 단위로 처리되며, 크기가 모자라면 패딩을 추가하여 512비트를 맞춥니다.
        - **패딩**: 데이터의 끝에 1비트를 추가하고, 이후 0비트로 채웁니다.
    - 마지막 블록에는 64비트 길이 정보가 추가되어 총 512비트를 맞추게 됩니다.

2. **초기 해시값**  
    - SHA-256은 8개의 32비트 초기 해시값을 사용합니다. 이 값은 상태 변수로, 입력 데이터의 블록들이 처리되는 동안 계속해서 갱신됩니다.

3. **메시지 블록 처리**  
    - 입력 데이터는 512비트 블록 단위로 처리됩니다. 각 블록은 32비트 단위로 나누어 16개의 워드로 시작합니다.
    - 이후 메시지 스케줄을 통해 16개의 워드를 기반으로 48개의 새로운 워드를 생성하여 총 64개의 워드가 됩니다.
        - 처음 16개 워드는 입력 데이터에서 직접 파생됩니다.
        - 이후 48개 워드는 입력 데이터와 관계 없는 값들로, 기존 워드들을 바탕으로 연산을 통해 생성됩니다.

4. **라운드 처리**  
    - SHA-256은 64번의 라운드로 이루어져 있으며, 각 라운드에서 상태 변수가 업데이트됩니다.
    - 상태 변수는 각 라운드마다 계산을 통해 계속 변화하고, 최종적으로 최종 해시값을 계산하는 데 사용됩니다.

5. **최종 해시값 생성**  
    - 64번의 라운드 처리가 끝난 후, 8개의 상태 변수 값 (H0 ~ H7)은 256비트의 최종 해시값으로 결합됩니다.

### 핵심 요약

- **패딩**을 통해 입력 데이터는 항상 512비트 블록으로 맞춰진다.
- 초기 **해시값**(8개의 32비트)으로 시작해, 64번의 라운드를 거쳐 최종적으로 **256비트 해시값**을 생성한다.
- **메시지 스케줄링**을 통해 64개의 워드가 생성되며, 각 라운드에서 상태 변수는 계속 갱신된다.
- **충돌 저항성과 보안성**을 높이는 방식으로 연산이 이루어진다.

---
## 비트코인 블록체인 주요 요소

1. **블록 해시**  
    - 블록 해시는 블록 간 연결성을 유지하고, 변경된 데이터를 탐지하는 역할을 합니다.

2. **작업 증명 (Proof of Work)**  
    - 비트코인 채굴자는 새로운 블록을 블록체인에 추가하기 위해 해시 퍼즐을 풀어야 합니다. 이 과정을 작업 증명이라고 하며, 네트워크의 보안성을 높입니다.

3. **트랜잭션 ID**  
    - 각 트랜잭션에는 트랜잭션 ID가 존재하며, 이는 트랜잭션의 변경 여부를 확인하고 무결성을 보장합니다.

4. **머클 트리**  
    - 머클 트리는 블록 내의 모든 트랜잭션을 요약하고, 데이터 검증 및 효율적인 검색을 가능하게 하는 중요한 기술입니다.

5. **비트코인 주소**  
    - 비트코인 주소는 비대칭키 암호화에서 공개키를 해싱하여 생성됩니다.

6. **디지털 서명**  
    - 디지털 서명은 트랜잭션의 무결성을 보장하고, 소유권을 증명하는 데 중요한 역할을 하며, 이 과정에서 해시 함수가 사용됩니다.

---

## 암호화 개념 및 블록체인에서의 활용

### 암호화와 복호화
- **암호화**: 원본 데이터를 비밀 키를 사용하여 암호문으로 변환.
- **복호화**: 암호화 과정에서 사용한 키로 암호문을 다시 평문으로 변환.

### 대칭키 암호화 (Symmetric Key Encryption)
- **대칭키 암호화**는 암호화 및 복호화에 동일한 키를 사용하는 방식입니다.
- 주로 파일 암호화, VPN, SSL/TLS 프로토콜에서 사용되며, 파일 전송이나 디지털 저장소 보호에서 중요한 역할을 합니다.
  
  **장점**
  - 상대적으로 빠르고 효율적.
  - 키가 안전하게 유지되면 매우 강력한 보안.

  **단점**
  - 동일한 키를 공유해야 하므로 안전하게 키를 교환하는 방법이 필요.

  **예시**
  - AES (파일 보호, 인터넷 뱅킹)
  - DES, RC4 (스트리밍, VPN)

### 비대칭키 암호화 (Asymmetric Key Encryption)
- **비대칭키 암호화**는 공개키와 개인키를 한 쌍으로 사용하는 방식입니다.
- 블록체인에서 사용되는 대부분의 암호화 방식.

  **과정**
  - 개인 키를 16진수 문자열로 변환한 뒤, **Base58Check 인코딩** 방식으로 변환하여 사용자가 쉽게 보관하고 관리할 수 있게 함.
  - **공개 키**는 개인 키로부터 생성되며, 공개 키에서 개인 키를 유추할 수는 없고, 개인 키에서 공개 키를 유추할 수 있음.
  - 공개 키는 다시 **SHA-256**과 **RIPEMD-160** 해싱을 거쳐 주소가 생성됩니다.

#### 공개 키로 암호화 (Public Key Encryption)
- **공개 키**로 암호화한 데이터는 해당 **개인 키**만으로 복호화 가능합니다.
- 이 방식은 데이터의 기밀성을 보장하며, 데이터 전송 중 도청되어도 개인 키를 소유한 사용자만 복호화할 수 있습니다.
  
  **예시**
  - **TLS/SSL**을 통한 보안 웹 통신 (HTTPS)
  - **SSH** (Secure Shell)
  - **암호화된 이메일** (PGP/GPG)
  - **클라우드 저장소**에서의 데이터 암호화

#### 개인 키로 암호화 (Private Key Encryption)
- **개인 키**로 암호화한 데이터는 공개 키를 통해 변경되었는지 여부를 확인할 수 있습니다.
- **디지털 서명**에서 사용되며, 데이터의 무결성과 송신자의 신원을 증명합니다.
  
  **예시**
  - **디지털 서명** (데이터의 무결성 및 송신자 인증)
  - **암호화폐** (거래의 인증 및 보안)
  - **전자서명** (계약서, 문서 서명)
  - **전자투표 시스템** (투표의 무결성 및 익명성 보장)

#### 블록체인에서의 공개키 및 개인키 활용
- **공개 키**
  - 블록체인 주소 생성에 사용.
  - 디지털 서명을 검증할 때 사용.
  
- **개인 키**
  - 트랜잭션 서명에 사용.
  - 블록체인 자산의 소유권을 증명.

---
## 디지털 서명

- **디지털 서명**은 개인 키로 생성되고, 공개 키로 검증할 수 있습니다. 이를 통해 데이터의 **무결성**과 **진위성**을 확인할 수 있습니다.
- **공개 키로 서명을 검증**할 때, 데이터 자체를 복호화하는 것은 아닙니다. 대신 해시 값만을 비교하여 검증합니다.

### 디지털 서명의 동작 방식
1. **해싱**: 원본 데이터를 해싱하여 고정된 길이의 해시 값을 생성합니다.
2. **서명**: 송신자의 **개인 키**를 사용하여 해시 값에 서명을 생성합니다. 서명은 암호화된 해시 값으로, 데이터의 무결성과 진위성을 보증합니다.
3. **검증**: 수신자는 송신자의 **공개 키**로 서명을 복호화하고, 원본 데이터를 알고 있기 때문에 원본 데이터를 해싱한 값과 복호화된 값을 비교하여 변조 여부를 확인합니다.

### 디지털 서명 시스템의 필요조건
- **알고리즘의 수준**
- **시스템 구현**
- **개인 키 보호**

### 타임스탬프에서의 디지털 서명 사용 목적
- 데이터의 **무결성**을 증명하고, 데이터의 **시간**을 인증하여 신뢰를 제공합니다.

### 비트코인에서 디지털 서명의 역할
- **트랜잭션 무결성**을 보장
- **소유권**을 증명
- **탈중앙화된 검증** (중앙 기관 없이 신뢰를 유지)
- **ECDSA**(타원 곡선 디지털 서명 알고리즘)를 사용하여 서명을 생성하고 검증
- **비트코인 주소**는 공개 키를 해싱하여 생성됩니다 (SHA-256 + RIPEMD-160)
- 디지털 서명은 **64바이트** 크기로 트랜잭션 데이터에 포함됩니다.

---
## OpenSSL을 이용한 ECC 개인 키와 공개 키 생성

OpenSSL의 ECC 함수를 사용하여 개인 키와 공개 키 쌍을 생성하는 방법을 CLI(Command Line Interface) 방식으로 설명합니다.

### 1. OpenSSL에서 지원되는 타원곡선 목록 확인
OpenSSL을 이용하여 지원되는 타원곡선 목록을 확인하려면 다음 명령어를 사용합니다.

```bash
% openssl ecparam -list_curves
```
이번에 사용할 타원곡선은 비트코인에서 사용하는 secp256k1입니다. 

### 2. 개인 키 생성
다음 명령어를 사용하여 secp256k1 타원곡선 기반의 개인 키를 생성합니다.

```bash
% openssl ecparam -name secp256k1 -genkey -noout -out privatekey.pem
```

### 3. 생성된 개인 키 확인
생성된 개인 키를 확인하려면 다음 명령어를 사용합니다.

```bash
% cat privatekey.pem
```

### 4. 공개 키 생성
개인 키로부터 공개 키를 생성하려면 다음 명령어를 사용합니다.

```bash
% openssl ec -in privatekey.pem -pubout -out pubkey.pem
```

### 5. 생성된 공개 키 확인
생성된 공개 키를 확인하려면 다음 명령어를 사용합니다.

```bash
% cat pubkey.pem
```

### 6. 개인 키의 상세 정보 출력
개인 키에 대한 상세 정보를 출력하려면 다음 명령어를 사용합니다.

```bash
% openssl ec -in privatekey.pem -text -noout
```

**출력 내용 설명**
read EC key: 입력된 키 파일이 타원 곡선 알고리즘에 적합한 키 파일임을 확인
Private-Key: (256 bit): 개인 키의 크기 (256 비트)
priv: 개인 키의 값
pub: 공개 키의 값. 공개 키는 개인 키와 타원 곡선의 기준점을 곱하여 계산됩니다.
공개 키의 형태:

첫 번째 바이트: 04 (비압축 공개 키를 나타냄)
나머지 값: x와 y 좌표를 16진수로 나열한 값

### 7. 공개 키의 상세 정보 출력
공개 키에 대한 상세 정보를 출력하려면 다음 명령어를 사용합니다.

```bash
% openssl ec -in pubkey.pem -pubin -text -noout
```

**참고**: 공개 키에서는 개인 키를 유추할 수 없습니다.

### 8. 공개 키로 개인 키를 유추할 수 없는 이유
개인 키에서 공개 키를 계산할 수 있지만, 공개 키에서 개인 키를 유추하는 것은 불가능합니다. 그 이유는 다음과 같습니다:

이산 로그 문제: 타원 곡선에서 특정 점을 기반으로 역연산을 하는 것이 매우 어렵기 때문입니다.
연산의 비대칭성: 공개 키에서 개인 키를 추출하는 계산은 매우 복잡하고 시간 복잡도가 높습니다.
타원 곡선의 높은 보안성: 타원 곡선 기반 암호화는 매우 높은 보안

---
