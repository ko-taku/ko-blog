# 2025년 1월 31일 - OT

- **OT**
    - **전반적인 채용시장**
    - **커리큘럼**
    - **어떠한 채용 전략을 가지고 있는지**
        - 개인의 매력을 향상시킨다.

## 마크다운 사용법

- [마크다운 사용법 가이드](https://gist.github.com/ihoneymon/652be052a0727ad59601)

# CLI 기본 명령어

### 기본 명령어

- **~** : root

#### **파일 및 디렉토리 관리**

> **`ls`, `rm` 사용 x**
- `pwd`: 현재 작업 중인 디렉토리 확인
- `ls`: 디렉토리 내 파일 및 폴더 목록 보기
- `cd`: 디렉토리 이동
- `..` : 상위 폴더 (한 단계 상위 폴더로 이동 cd ..|두 단계 상위 폴더로 이동 : cd ../..)
- `mkdir`: 디렉토리 생성
- `touch`: 빈 파일 생성
- `cp`: 파일 복사
- `mv`: 파일 이동 또는 이름 변경
- `rm`: 파일 삭제
- `rmdir`: 빈 디렉토리 삭제

#### **시스템 정보 확인**
- `whoami`: 현재 사용자 확인
- `uname`: 시스템 정보 확인
- `df`: 디스크 사용량 확인
- `top` 또는 `htop`: 시스템 프로세스 확인

#### **기타 유용한 명령어**
- `clear`: 터미널 화면 정리
- `history`: 명령어 기록 확인
- `man`: 명령어 매뉴얼 확인 (예: `man ls`)

### **파일 내용 조회 및 편집**

- `cat`: 파일 내용 출력
- `more` 또는 `less`: 파일 내용 페이지 단위로 출력
- `head`: 파일의 앞부분 출력
- `tail`: 파일의 끝부분 출력
- `grep`: 파일 내 특정 문자열 검색
- `nano` 또는 `vim`: CLI 기반 텍스트 편집기 사용

### **권한 및 사용자 관리**

- `chmod`: 파일 권한 변경 (읽기, 쓰기, 실행 권한)
- `chown`: 파일 소유자 변경
- `sudo`: 관리자 권한으로 명령어 실행
- `useradd` 및 `passwd`: 사용자 추가 및 비밀번호 설정

# Vim 기본 사용법

Vim은 모드 기반으로 동작합니다. 주요 모드는 다음과 같다

### **1. 일반 모드 (Normal Mode)**

- **기능**: 커서 이동, 텍스트 삭제, 복사, 붙여넣기 등
- **진입 방법**: `Esc` 키를 누르면 일반 모드로 돌아옴
- **주요 명령어**
  - `h`, `j`, `k`, `l`: 왼쪽, 아래, 위, 오른쪽으로 커서 이동
  - `x`: 커서 위치의 문자 삭제
  - `dd`: 현재 줄 삭제
  - `yy`: 현재 줄 복사
  - `p`: 붙여넣기
  - `u`: 실행 취소
  - `Ctrl + r`: 다시 실행

### **2. 입력 모드 (Insert Mode)**

- **기능**: 텍스트 입력
- **진입 방법**
  - `i`: 커서 위치에서 입력 모드 시작
  - `a`: 커서 다음 위치에서 입력 모드 시작
  - `o`: 현재 줄 아래에 새 줄을 추가하고 입력 모드 시작
- **종료 방법**: `Esc` 키를 눌러 일반 모드로 돌아온다

### **3. 명령 모드 (Command Mode)**

- **기능**: 파일 저장, 종료, 검색 등
- **진입 방법**: 일반 모드에서 `:`를 입력
- **주요 명령어**
  - `:w`: 파일 저장
  - `:q`: Vim 종료
  - `:wq`: 파일 저장 후 종료
  - `:q!`: 저장하지 않고 강제 종료
  - `:/검색어`: 텍스트 검색
  - `:set nu`: 줄 번호 표시
  - `:set nonu`: 줄 번호 숨기기

 
# 2025년 2월 3일 TIL

## 오늘 한 일

### 블록체인 기술의 시작과 매커니즘에 대해 알아보았다

- **블록체인**은 디지털 문서의 타임 스탬프를 보장하기 위한 아이디어에서 출발한 기술.
- **블록체인**은 데이터를 안전하게 보호하기 위해 **암호화 기술**을 사용한다. 그 중 **디지털 서명**과 **해시**가 주요 암호화 기술이다.

#### 디지털 서명
- 트랜잭션을 보낸 사람의 신원을 확인하고, 데이터가 변조되지 않았음을 보장.

#### 해시 함수
- 블록의 고유한 해시값을 계산하여, 블록의 내용이 변경되지 않았음을 확인한다.
- 해시값은 블록에 대한 **불변성**을 보장하는 중요한 역할을 한다.

### 블록체인의 매커니즘

- **블록체인**은 **블록**이라는 데이터 단위로 이루어져 있으며, 각 블록은 여러 정보를 담고 있고 주로 **트랜잭션** 정보를 포함한다.
- 각 블록의 정보 구성:
  - **트랜잭션 목록**: 이 블록에 기록된 트랜잭션 정보.
  - **타임스탬프**: 블록이 생성된 시간.
  - **이전 블록의 해시**: 해당 블록이 이전 블록과 연결될 수 있도록 하는 값.
  - **블록 해시**: 현재 블록을 고유하게 식별하는 암호화된 해시 값.

- 각 블록은 **이전 블록의 해시**를 포함하고 있어 이를 통해 블록들이 체인 형태로 연결된다.
- 이러한 방식으로 하나의 블록이 변경되면 연결된 **모든 블록의 해시**가 변경되어 **변경 사항을 추적**할 수 있다. 이를 통해 **불변성**을 유지할 수 있다.

### 실물화폐와 신용화폐, 암호화폐의 역사에 대해 배웠다

- **화폐**가 가지고 있는 특성과 기능이 **암호화폐**에 어떻게 적용되는지 배웠다.

#### 화폐의 특성:
- **휴대성**
- **가분성**
- **내구성**
- **동질성**
- **가치의 안정성**

#### 화폐의 기능:
- **교환매개체 기능**: 빠른 거래 방식에 아직은 적합하지 않음.
- **가치척도의 기능**: 가격 변동이 심해 어려움.
- **가치 저장 기능**: 디지털 자산 역할.

### 탈중앙화된 문화를 옹호하는 사회 운동이 시작된 일련의 과정을 배웠다

- **서브프라임 모기지**: 미국의 초저금리 경기부양책 이후 벌어진 금융위기.
- **양적완화**: 금융위기를 해결하기 위한 방안이지만 여러 부작용을 초래:
  - 자산 가격 버블
  - 인플레이션 위험
  - 부의 양극화 심화
  - 달러 가치 하락과 환율 문제
  - 금융 시스템 왜곡
  - 정책 의존성 증가
  - 국제적 불균형 확대
  
- **사이버펑크**: 개인의 프라이버시를 중요시 생각한 사람들이 만든 단체로, 탈중앙화된 문화를 옹호하는 사회 운동을 시작.

# 맥 환경 설정 작업

**Homebrew 설치**

Homebrew를 설치하려면 터미널에서 아래 명령어를 실행합니다:

/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"


## nvm 다운로드 및 설치 및 Node.js 설치

터미널에서 아래 명령어를 실행하여 `nvm`을 설치합니다:

curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash

nvm 설치 후 zsh: command not found: nvm 나왔을 때 환경변수 설정이 안되어 있어서 설정해줘야한다

터미널에서 source ~/.nvm/nvm.sh로 환경변수 설정 이후 진행

설치 후 nvm ls로 버전 확인

버전을 맞춰주는 작업 nvm install 16.20.2로 버전을 다운받음

nvm use 16.20.2로 원하는 버전으로 설정해준다

# 2025년 2월 4일 TIL

## 타임스탬프 해시 생성과정

1. **입력 데이터의 해시 생성**  
    - 입력 데이터를 해시 함수(예: SHA-256)에 통과시켜 고정된 길이의 해시 값을 생성합니다.

2. **타임스탬프 기관에 제출**  
    - 생성된 해시 값을 타임스탬프 기관에 제출합니다. 기관은 해당 해시 값에 타임스탬프를 추가하고, 디지털 서명을 통해 데이터를 인증합니다.

3. **타임스탬프와 서명 반환**  
    - 타임스탬프 기관은 타임스탬프와 서명이 포함된 결과를 사용자에게 반환합니다.

4. **데이터 검증**  
    - 나중에 데이터를 검증하려면, 사용자가 원본 데이터에서 해시 값을 다시 계산한 후, 기관이 제공한 해시 값을 비교합니다.  
    - 해시 값이 일치하면 데이터가 변조되지 않았음을 확인할 수 있습니다.

5. **체인 구조 (선택적)**  
    - 여러 타임스탬프를 체인 형태로 연결하여 이전 타임스탬프의 해시 값을 포함시킬 수도 있습니다.  
    - 이를 통해 데이터의 시간 순서와 무결성을 보장합니다.

---

## SHA-256 알고리즘 요약

1. **입력 데이터 처리**  
    - 입력된 데이터는 아스키 코드로 표현된 이진 데이터로 변환됩니다.  
    - 데이터는 512비트 블록 단위로 처리되며, 크기가 모자라면 패딩을 추가하여 512비트를 맞춥니다.
        - **패딩**: 데이터의 끝에 1비트를 추가하고, 이후 0비트로 채웁니다.
    - 마지막 블록에는 64비트 길이 정보가 추가되어 총 512비트를 맞추게 됩니다.

2. **초기 해시값**  
    - SHA-256은 8개의 32비트 초기 해시값을 사용합니다. 이 값은 상태 변수로, 입력 데이터의 블록들이 처리되는 동안 계속해서 갱신됩니다.

3. **메시지 블록 처리**  
    - 입력 데이터는 512비트 블록 단위로 처리됩니다. 각 블록은 32비트 단위로 나누어 16개의 워드로 시작합니다.
    - 이후 메시지 스케줄을 통해 16개의 워드를 기반으로 48개의 새로운 워드를 생성하여 총 64개의 워드가 됩니다.
        - 처음 16개 워드는 입력 데이터에서 직접 파생됩니다.
        - 이후 48개 워드는 입력 데이터와 관계 없는 값들로, 기존 워드들을 바탕으로 연산을 통해 생성됩니다.

4. **라운드 처리**  
    - SHA-256은 64번의 라운드로 이루어져 있으며, 각 라운드에서 상태 변수가 업데이트됩니다.
    - 상태 변수는 각 라운드마다 계산을 통해 계속 변화하고, 최종적으로 최종 해시값을 계산하는 데 사용됩니다.

5. **최종 해시값 생성**  
    - 64번의 라운드 처리가 끝난 후, 8개의 상태 변수 값 (H0 ~ H7)은 256비트의 최종 해시값으로 결합됩니다.

### 핵심 요약

- **패딩**을 통해 입력 데이터는 항상 512비트 블록으로 맞춰진다.
- 초기 **해시값**(8개의 32비트)으로 시작해, 64번의 라운드를 거쳐 최종적으로 **256비트 해시값**을 생성한다.
- **메시지 스케줄링**을 통해 64개의 워드가 생성되며, 각 라운드에서 상태 변수는 계속 갱신된다.
- **충돌 저항성과 보안성**을 높이는 방식으로 연산이 이루어진다.

---
## 비트코인 블록체인 주요 요소

1. **블록 해시**  
    - 블록 해시는 블록 간 연결성을 유지하고, 변경된 데이터를 탐지하는 역할을 합니다.

2. **작업 증명 (Proof of Work)**  
    - 비트코인 채굴자는 새로운 블록을 블록체인에 추가하기 위해 해시 퍼즐을 풀어야 합니다. 이 과정을 작업 증명이라고 하며, 네트워크의 보안성을 높입니다.

3. **트랜잭션 ID**  
    - 각 트랜잭션에는 트랜잭션 ID가 존재하며, 이는 트랜잭션의 변경 여부를 확인하고 무결성을 보장합니다.

4. **머클 트리**  
    - 머클 트리는 블록 내의 모든 트랜잭션을 요약하고, 데이터 검증 및 효율적인 검색을 가능하게 하는 중요한 기술입니다.

5. **비트코인 주소**  
    - 비트코인 주소는 비대칭키 암호화에서 공개키를 해싱하여 생성됩니다.

6. **디지털 서명**  
    - 디지털 서명은 트랜잭션의 무결성을 보장하고, 소유권을 증명하는 데 중요한 역할을 하며, 이 과정에서 해시 함수가 사용됩니다.

---

## 암호화 개념 및 블록체인에서의 활용

### 암호화와 복호화
- **암호화**: 원본 데이터를 비밀 키를 사용하여 암호문으로 변환.
- **복호화**: 암호화 과정에서 사용한 키로 암호문을 다시 평문으로 변환.

### 대칭키 암호화 (Symmetric Key Encryption)
- **대칭키 암호화**는 암호화 및 복호화에 동일한 키를 사용하는 방식입니다.
- 주로 파일 암호화, VPN, SSL/TLS 프로토콜에서 사용되며, 파일 전송이나 디지털 저장소 보호에서 중요한 역할을 합니다.
  
  **장점**
  - 상대적으로 빠르고 효율적.
  - 키가 안전하게 유지되면 매우 강력한 보안.

  **단점**
  - 동일한 키를 공유해야 하므로 안전하게 키를 교환하는 방법이 필요.

  **예시**
  - AES (파일 보호, 인터넷 뱅킹)
  - DES, RC4 (스트리밍, VPN)

### 비대칭키 암호화 (Asymmetric Key Encryption)
- **비대칭키 암호화**는 공개키와 개인키를 한 쌍으로 사용하는 방식입니다.
- 블록체인에서 사용되는 대부분의 암호화 방식.

  **과정**
  - 개인 키를 16진수 문자열로 변환한 뒤, **Base58Check 인코딩** 방식으로 변환하여 사용자가 쉽게 보관하고 관리할 수 있게 함.
  - **공개 키**는 개인 키로부터 생성되며, 공개 키에서 개인 키를 유추할 수는 없고, 개인 키에서 공개 키를 유추할 수 있음.
  - 공개 키는 다시 **SHA-256**과 **RIPEMD-160** 해싱을 거쳐 주소가 생성됩니다.

#### 공개 키로 암호화 (Public Key Encryption)
- **공개 키**로 암호화한 데이터는 해당 **개인 키**만으로 복호화 가능합니다.
- 이 방식은 데이터의 기밀성을 보장하며, 데이터 전송 중 도청되어도 개인 키를 소유한 사용자만 복호화할 수 있습니다.
  
  **예시**
  - **TLS/SSL**을 통한 보안 웹 통신 (HTTPS)
  - **SSH** (Secure Shell)
  - **암호화된 이메일** (PGP/GPG)
  - **클라우드 저장소**에서의 데이터 암호화

#### 개인 키로 암호화 (Private Key Encryption)
- **개인 키**로 암호화한 데이터는 공개 키를 통해 변경되었는지 여부를 확인할 수 있습니다.
- **디지털 서명**에서 사용되며, 데이터의 무결성과 송신자의 신원을 증명합니다.
  
  **예시**
  - **디지털 서명** (데이터의 무결성 및 송신자 인증)
  - **암호화폐** (거래의 인증 및 보안)
  - **전자서명** (계약서, 문서 서명)
  - **전자투표 시스템** (투표의 무결성 및 익명성 보장)

#### 블록체인에서의 공개키 및 개인키 활용
- **공개 키**
  - 블록체인 주소 생성에 사용.
  - 디지털 서명을 검증할 때 사용.
  
- **개인 키**
  - 트랜잭션 서명에 사용.
  - 블록체인 자산의 소유권을 증명.

---
## 디지털 서명

- **디지털 서명**은 개인 키로 생성되고, 공개 키로 검증할 수 있습니다. 이를 통해 데이터의 **무결성**과 **진위성**을 확인할 수 있습니다.
- **공개 키로 서명을 검증**할 때, 데이터 자체를 복호화하는 것은 아닙니다. 대신 해시 값만을 비교하여 검증합니다.

### 디지털 서명의 동작 방식
1. **해싱**: 원본 데이터를 해싱하여 고정된 길이의 해시 값을 생성합니다.
2. **서명**: 송신자의 **개인 키**를 사용하여 해시 값에 서명을 생성합니다. 서명은 암호화된 해시 값으로, 데이터의 무결성과 진위성을 보증합니다.
3. **검증**: 수신자는 송신자의 **공개 키**로 서명을 복호화하고, 원본 데이터를 알고 있기 때문에 원본 데이터를 해싱한 값과 복호화된 값을 비교하여 변조 여부를 확인합니다.

### 디지털 서명 시스템의 필요조건
- **알고리즘의 수준**
- **시스템 구현**
- **개인 키 보호**

### 타임스탬프에서의 디지털 서명 사용 목적
- 데이터의 **무결성**을 증명하고, 데이터의 **시간**을 인증하여 신뢰를 제공합니다.

### 비트코인에서 디지털 서명의 역할
- **트랜잭션 무결성**을 보장
- **소유권**을 증명
- **탈중앙화된 검증** (중앙 기관 없이 신뢰를 유지)
- **ECDSA**(타원 곡선 디지털 서명 알고리즘)를 사용하여 서명을 생성하고 검증
- **비트코인 주소**는 공개 키를 해싱하여 생성됩니다 (SHA-256 + RIPEMD-160)
- 디지털 서명은 **64바이트** 크기로 트랜잭션 데이터에 포함됩니다.

---
## OpenSSL을 이용한 ECC 개인 키와 공개 키 생성

OpenSSL의 ECC 함수를 사용하여 개인 키와 공개 키 쌍을 생성하는 방법을 CLI(Command Line Interface) 방식으로 설명합니다.

### 1. OpenSSL에서 지원되는 타원곡선 목록 확인
OpenSSL을 이용하여 지원되는 타원곡선 목록을 확인하려면 다음 명령어를 사용합니다.

```bash
% openssl ecparam -list_curves
```
이번에 사용할 타원곡선은 비트코인에서 사용하는 secp256k1입니다. 

### 2. 개인 키 생성
다음 명령어를 사용하여 secp256k1 타원곡선 기반의 개인 키를 생성합니다.

```bash
% openssl ecparam -name secp256k1 -genkey -noout -out privatekey.pem
```

### 3. 생성된 개인 키 확인
생성된 개인 키를 확인하려면 다음 명령어를 사용합니다.

```bash
% cat privatekey.pem
```

### 4. 공개 키 생성
개인 키로부터 공개 키를 생성하려면 다음 명령어를 사용합니다.

```bash
% openssl ec -in privatekey.pem -pubout -out pubkey.pem
```

### 5. 생성된 공개 키 확인
생성된 공개 키를 확인하려면 다음 명령어를 사용합니다.

```bash
% cat pubkey.pem
```

### 6. 개인 키의 상세 정보 출력
개인 키에 대한 상세 정보를 출력하려면 다음 명령어를 사용합니다.

```bash
% openssl ec -in privatekey.pem -text -noout
```

**출력 내용 설명**
read EC key: 입력된 키 파일이 타원 곡선 알고리즘에 적합한 키 파일임을 확인
Private-Key: (256 bit): 개인 키의 크기 (256 비트)
priv: 개인 키의 값
pub: 공개 키의 값. 공개 키는 개인 키와 타원 곡선의 기준점을 곱하여 계산됩니다.
공개 키의 형태:

첫 번째 바이트: 04 (비압축 공개 키를 나타냄)
나머지 값: x와 y 좌표를 16진수로 나열한 값

### 7. 공개 키의 상세 정보 출력
공개 키에 대한 상세 정보를 출력하려면 다음 명령어를 사용합니다.

```bash
% openssl ec -in pubkey.pem -pubin -text -noout
```

**참고**: 공개 키에서는 개인 키를 유추할 수 없습니다.

### 8. 공개 키로 개인 키를 유추할 수 없는 이유
개인 키에서 공개 키를 계산할 수 있지만, 공개 키에서 개인 키를 유추하는 것은 불가능합니다. 그 이유는 다음과 같습니다:

이산 로그 문제: 타원 곡선에서 특정 점을 기반으로 역연산을 하는 것이 매우 어렵기 때문입니다.
연산의 비대칭성: 공개 키에서 개인 키를 추출하는 계산은 매우 복잡하고 시간 복잡도가 높습니다.
타원 곡선의 높은 보안성: 타원 곡선 기반 암호화는 매우 높은 보안

---
# 2025년 2월 5일 TIL

## 비트코인 블록 구조

비트코인의 블록은 **블록 헤더**와 **블록 바디**로 구성됩니다.

### 블록 헤더

블록 헤더는 블록에 대한 **메타데이터**를 포함하며, 블록의 고유 식별자 역할을 합니다. 블록 헤더의 크기는 **80바이트**로 고정되어 있습니다.

#### 블록 헤더의 주요 구성 요소

1. **이전 블록 해시**  
   - 이전 블록의 해시 값으로, 블록 간 연결성을 제공하고 **체인을 형성**합니다.  
   - 블록체인의 무결성을 보장합니다.

2. **머클 루트**  
   - 블록에 포함된 모든 트랜잭션의 해시 값을 결합하여 생성된 트리의 **루트 해시 값**입니다.  
   - 이를 통해 블록 내 모든 트랜잭션이 변경되지 않았음을 증명할 수 있습니다.

3. **타임스탬프**  
   - 블록이 생성된 시간을 나타내며, **UNIX 타임스탬프** 형식으로 저장됩니다.  
   - **초 단위**로 기록됩니다.

4. **난이도 타겟**  
   - 현재 블록 생성의 난이도를 정의하는 값입니다.  
   - 네트워크의 작업 증명 목표를 설정합니다.

5. **논스 (Nonce)**  
   - **작업 증명(PoW)**에서 정답을 찾기 위해 반복적으로 변경되는 값입니다.  
   - 채굴자는 이 값을 변경하면서 올바른 블록 해시를 찾기 위해 시도합니다.

6. **버전**  
   - 블록이 사용하고 있는 비트코인 프로토콜의 버전 정보입니다.



### 블록 바디

블록 바디는 **트랜잭션 데이터**를 저장합니다. 트랜잭션은 **코인베이스 트랜잭션**과 **일반 트랜잭션**으로 구성됩니다.

1. **코인베이스 트랜잭션**  
   - 블록을 생성한 채굴자에게 보상이 지급되는 트랜잭션입니다.  
   - 이는 항상 블록의 첫 번째 트랜잭션으로 포함됩니다.

2. **일반 트랜잭션**  
   - 블록에 포함된 **비트코인 전송 기록**입니다.  
   - 트랜잭션의 개수는 네트워크의 사태와 트랜잭션 용량에 따라 달라집니다.



## 트랜잭션 데이터 구조

트랜잭션은 **입력(Input)**과 **출력(Output)**으로 구성됩니다.  
각각은 **비트코인 네트워크에서 자금 흐름을 관리**하는 데 중요한 역할을 합니다.



## 비트코인 블록 크기

- **블록헤더**: 고정 크기 **80바이트**
- **트랜잭션 데이터**: 나머지 공간을 차지하며, **1MB** 또는 **4MB**까지 처리할 수 있습니다 (SegWit 활성화 이후).



## 비트코인 블록체인의 트랜잭션 구조

비트코인 블록체인의 **트랜잭션 구조**는 **송금 요청을 기록하고 검증**하는 데 사용되는 데이터 구조입니다.  
이 구조를 통해 비트코인 네트워크의 트랜잭션이 안전하게 관리됩니다.

---
## 트랜잭션의 주요 구성 요소

### 1. 버전
- 트랜잭션의 형식을 정의하는 숫자 필드입니다.
- 현재 사용 중인 비트코인 버전은 1과 2이며, 향후 업데이트를 대비해 사용됩니다.
- **크기**: 4바이트

### 2. 입력
- 입력은 트랜잭션이 사용하는 **이전 트랜잭션의 출력(UTXO)**을 참조합니다.  
- 입력에는 송신자의 서명이 포함된 정보가 담깁니다.

#### UTXO (미사용된 트랜잭션의 출력)
- **UTXO**는 비트코인 자금 출처 관리의 핵심 요소로, 자금 출처 추적, 잔고 관리, 트랜잭션의 근거로 사용됩니다.

##### 구성 요소
- **a. 트랜잭션 해시**  
  - 현재 트랜잭션이 참조하는 이전 트랜잭션의 해시 값입니다.  
  - **크기**: 32바이트

- **b. 출력 인덱스**  
  - 참조하는 트랜잭션에서 어떤 출력을 사용하는지 나타냅니다. (0부터 시작하는 인덱스)  
  - 즉, 지출할 UTXO입니다.  
  - **크기**: 4바이트

- **c. 스크립트 길이**  
  - 잠금 해제 스크립트의 길이를 나타냅니다.  
  - **크기**: 가변

- **d. 스크립트 서명**  
  - 이전 트랜잭션 출력의 소유권을 증명하기 위한 서명과 공개키로 구성된 스크립트입니다.  
  - 공개키와 디지털 서명이 포함됩니다.

- **e. 시퀀스 번호**  
  - 트랜잭션이 취소되거나 수정될 가능성을 나타내는 필드로, 현재는 거의 사용되지 않습니다.  
  - **크기**: 4바이트

### 3. 출력
- 출력은 수신자에게 전달되는 비트코인의 정보를 포함합니다.  
- 한 트랜잭션은 여러 개의 출력을 가질 수 있습니다.

##### 구성 요소
- **a. 출력 금액**  
  - 해당 출력에 포함된 비트코인의 금액을 나타냅니다.  
  - **단위**: 사토시 (1 비트코인 = 10^8 사토시)  
  - **크기**: 8바이트

- **b. 스크립트 길이**  
  - 잠금 스크립트의 길이를 나타냅니다.  
  - **크기**: 가변

- **c. 잠금 스크립트**  
  - 비트코인을 잠금(수신자의 주소를 설정)하는 스크립트입니다.  
  - 일반적으로 **P2PKH** 스크립트 형식을 사용하며 수신자의 주소를 포함합니다.

### 4. 잠금 스크립트와 해제 스크립트 예시

#### P2PKH (Pay-to-PubKey-Hash) 형식
- **잠금 해제 스크립트 (ScriptSig)**: 입력에서 사용되며, 이전 트랜잭션 출력의 소유권을 증명하기 위해 사용됩니다.  
  - 예: `<Signature> <Public Key>`
  
- **잠금 스크립트 (ScriptPubKey)**: 출력에서 사용되며, 수신자에게 비트코인을 보낼 주소를 지정합니다.  
  - 예: `OP_DUP OP_HASH160 <Recipient's Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG`

### 5. 트랜잭션 카운터
- 트랜잭션에 포함된 **입력**과 **출력**의 개수를 기록합니다.  
- 각각 입력 개수와 출력 개수를 별도로 저장하며, 네트워크가 각 트랜잭션의 크기를 빠르게 파악할 수 있게 합니다.  
- **크기**: 가변 (1바이트 이상, 비트코인 직렬화와 규칙에 따라 달라짐)

### 6. 잠금 시간
- 해당 트랜잭션이 유효해지는 조건을 나타냅니다.  
- 특정 블록 높이 또는 타임스탬프가 설정될 수 있으며, 이 조건이 충족되어야 트랜잭션이 유효합니다.  
- **크기**: 4바이트

---

### 트랜잭션 흐름의 요약

1. **송신자**는 입력에서 이전 트랜잭션 출력을 참조합니다.
2. 해당 입력에 **개인 키로 디지털 서명을 생성**하여 서명 스크립트(ScriptSig)에 포함합니다.
3. 송신자는 비트코인을 보낼 **수신자의 주소를 출력에 지정**하며, 잠금 스크립트(ScriptPubKey)를 생성합니다.
4. **수신자**는 잠금 스크립트를 해제하기 위해 자신의 공개 키와 서명을 제공합니다.
5. 네트워크 노드는 **입력과 출력의 검증을 수행**하여 트랜잭션이 올바른지 확인합니다.

---
## UTXO (미사용 트랜잭션 출력)

### UTXO 개념
- **UTXO**는 **출력에서 미사용된 상태**인 트랜잭션을 말합니다.
- 비트코인 네트워크에서 사용자의 잔고와 트랜잭션을 추적하는 기본 단위입니다.
- 사용자가 보유한 비트코인의 총량은 해당 사용자가 소유한 **UTXO의 합계**로 계산됩니다.
- **트랜잭션 검증**: UTXO는 트랜잭션의 입력으로 참조되며, 이미 소비된 UTXO는 다시 사용할 수 없기 때문에 **이중 지불을 방지**합니다.

### UTXO 동작 방식

#### 생성
- 트랜잭션의 출력으로 새 UTXO가 생성됩니다.
- 이 출력은 비트코인 주소로 잠겨 있으며, 해당 주소의 소유자만이 이를 소비할 수 있습니다.

#### 소비
- 트랜잭션의 입력은 기존 UTXO를 참조하여 소비됩니다.
- 소비된 UTXO는 더 이상 유효하지 않으며, 새로운 UTXO가 생성됩니다.

### UTXO 구조

1. **금액**: 해당 UTXO에 저장된 비트코인의 양
2. **트랜잭션 스크립트**: 소유자 정보가 저장된 트랜잭션 스크립트 형태
3. **트랜잭션 ID**: 이 UTXO를 생성한 트랜잭션의 고유 식별자
4. **출력 인덱스**: 해당 트랜잭션에서 이 UTXO가 몇 번째 출력인지를 나타내는 번호

> **참고**: 채굴자에게 지급된 수수료는 독립된 UTXO로 생성되지 않고, 블록 보상의 일부로 **코인베이스 트랜잭션**에 포함됩니다. 이 코인베이스 트랜잭션은 블록을 채굴했을 때 처음에 한 번만 제공됩니다.

### UTXO와 트랜잭션의 관계

#### 트랜잭션 입력
- 기존 UTXO를 참조하여 해당 금액을 소비합니다.

#### 트랜잭션 출력
- 새로운 UTXO를 생성하여 수신자 또는 잔돈으로 보냅니다.

#### 이중 지불 방지
- 이미 소비된 UTXO는 다시 사용할 수 없으므로 동일 금액을 반복 사용하려는 시도를 방지합니다.

### UTXO의 저장 및 관리

#### 잔고 계산
- 사용자의 잔고는 그들이 보유한 모든 **잔돈 UTXO**의 합계로 계산됩니다.
- 비트코인 네트워크는 **계좌 방식**이 아니라 독립적인 **UTXO 목록**을 통해 잔고를 추적합니다.

#### UTXO 세트
- 네트워크 노드는 전체 네트워크의 사용되지 않은 출력 목록(UTXO 세트)을 유지합니다.
- 이 목록은 새로운 트랜잭션을 생성할 때 **입력으로 사용할 수 있는 UTXO**를 추적합니다.
- 트랜잭션 검증 시 참조된 UTXO의 유효성을 확인하는 데 사용됩니다.

#### 저장소 요구사항
- 시간이 지남에 따라 트랜잭션 수와 사용되지 않은 출력이 누적되어 UTXO 세트의 크기가 증가합니다.
- 이는 네트워크의 저장소와 처리 부담을 증가시키며, 각 노드는 최신 UTXO 세트를 유지하기 위해 **상당한 저장소**를 요구합니다.

### UTXO의 장점과 단점

#### 장점
1. **보안성**: UTXO는 이중 지불을 방지하고 네트워크 무결성을 보장합니다.
2. **병렬 처리 기능**: 서로 독립적인 UTXO를 사용하면 병렬로 트랜잭션을 처리할 수 있습니다. 이를 통해 트랜잭션 처리 속도가 빨라지고, 더 많은 사용자가 네트워크를 이용할 수 있습니다.

#### 단점
1. **복잡한 잔돈 관리**: 트랜잭션마다 잔돈 UTXO가 새로 생성되므로 UTXO 세트가 빠르게 증가할 수 있습니다.
2. **저장소 부담**: 전체 네트워크의 UTXO 데이터를 유지하는 데 **상당한 저장소**가 필요합니다.

#### UTXO 소비 시 스크립트 언어 사용
- UTXO를 소비하려면 스크립트 언어를 통해 트랜잭션의 유효성을 확인해야 합니다.

### UTXO 검증(연산자 사용)
- **소유권 검증**: `OP_CHECKSIG`와 `OP_HASH160`을 활용하여 소유자를 확인합니다.
- **출력 검증**: `OP_EQUAL`과 `OP_VERIFY`를 통해 출력 주소와 금액이 올바른지 확인합니다.
- **보안성 강화**: `OP_DUP`과 `OP_CHECKMULTISIG`로 다중 서명 및 공개 키 변조 방지를 강화합니다.
---
## 머클 루트

### 머클 트리

- **머클 트리(Merkle Tree)**는 여러 데이터에 대해 단계적으로 해시 함수를 적용하여 최종적으로 **머클 루트(Merkle Root)**라는 하나의 최상단 해시값을 생성하는 데이터 구조입니다.
- 구체적으로 블록체인의 각 **트랜잭션 데이터를 해싱한 값**들을 결합하여 부모 노드를 만들고, 이를 반복하여 **루트 노드**를 생성합니다.
- **목적**: 데이터의 무결성을 보장하고 위변조를 방지하기 위해 사용됩니다.

#### 머클 트리의 동작 과정

1. **트랜잭션 해싱**:
   - 블록에 포함된 각 트랜잭션의 해시값을 계산합니다.
   - 예를 들어, 트랜잭션 A와 트랜잭션 B의 해시값을 계산한 후 `H(A)`와 `H(B)`를 SHA-256 해싱합니다.
   - 각 해시값은 256비트 크기의 해시 값을 가집니다.
   
2. **결합**:
   - 두 해시값을 결합하면 512비트의 값이 됩니다. 
   - 이 512비트 값을 다시 SHA-256 해싱하여 **부모 노드**를 생성합니다.

3. **반복**:
   - 이러한 과정을 반복하여 트리의 최상단에 **머클 루트**를 도출합니다.

4. **머클 루트 생성**:
   - 모든 트랜잭션을 해싱하고 결합하여 마지막으로 최상단의 **머클 루트**가 생성됩니다.
   - 이 최상단의 해시값은 **블록 헤더**에 포함되어 블록의 고유성을 보장합니다.

#### 예시
- 트랜잭션 `H(A)`와 `H(B)`는 각각 SHA-256 해싱을 통해 256바이트의 해시값을 가지며, 이 두 값을 결합하여 다시 SHA-256 해싱을 진행합니다.
- 이 과정을 반복하여 **최상단 머클 루트**가 도출됩니다.

> **참고**: 패딩이 필요 없는 이유는 첫 번째 해싱에서 입력 크기에 따라 패딩이 추가될 수 있지만, 두 번째 해싱에서는 256바이트로 고정된 길이를 처리하기 때문에 패딩이 필요 없습니다.

### 머클 루트의 중요성

#### 블록 헤더
- **머클 루트**는 **블록 헤더**에 저장되며 블록체인 네트워크에서 작업 증명을 수행할 때 중요한 역할을 합니다.
- 블록의 무결성을 증명하고, 트랜잭션의 변경 여부를 빠르게 확인할 수 있도록 해줍니다.

#### 경량화된 노드
- **경량화된 노드(Light Client)**는 블록체인의 전체 데이터를 다운로드하지 않고, **머클 루트**를 사용해 특정 트랜잭션의 유효성을 검증할 수 있습니다.
- 이를 통해 저장소와 네트워크 대역폭을 절약하면서도, 블록체인의 데이터를 검증할 수 있습니다.

#### 보안과 투명성
- **트랜잭션 변경 시 머클 루트가 달라짐**: 블록 내에서 하나의 트랜잭션 값이 변경되면 머클 루트가 달라지고, 이로 인해 **블록 해시 값**이 변경됩니다.
- **블록체인의 연쇄 구조**: 각 블록은 이전 블록의 해시값을 포함하므로, 한 블록의 변경은 **연쇄적으로** 다른 블록의 해시 값도 변경하게 됩니다.
- **위변조 방지**: 트랜잭션을 악의적으로 변경하면 해당 트랜잭션으로 인해 머클 루트 값이 달라지고, 이로 인해 전체 블록체인의 무결성이 깨집니다.

### 블록체인의 무결성과 합의 매커니즘

- 블록체인은 **무결성**을 보장하기 위해 머클 루트를 사용하고, **51% 공격** 방어를 통해 **보안성**을 강화합니다.
  - **51% 공격**: 악의적인 노드가 변경된 체인을 네트워크에 전파하더라도, 네트워크 전체 노드의 **51% 이상**에 해당하는 컴퓨팅 파워를 확보하지 않는 한 이 체인은 유효하지 않은 것으로 간주됩니다.
  
### 결론
- **머클 트리**와 **머클 루트**는 블록체인에서 트랜잭션의 무결성을 보장하고, 데이터 위변조를 방지하는 중요한 역할을 합니다.  
- 또한, 경량화된 노드를 가능하게 하여 블록체인 네트워크의 효율성과 보안성을 높이는 중요한 기술입니다.
---
## 비트코인 코어 설치 및 테스트넷 노드 운용 실습

### 1. Homebrew 설치 및 버전 확인
Homebrew가 설치되어 있지 않다면 먼저 설치 후 버전을 확인합니다.

brew --version

### 2. Bitcoin Core 설치
Homebrew를 통해 Bitcoin Core를 설치합니다.

brew install bitcoin

objectivec

설치 후 비트코인 CLI 버전 확인:

bitcoin-cli --version

### 3. 비트코인 데이터 저장 디렉토리 생성
비트코인 데이터를 저장할 디렉토리를 생성하고 해당 디렉토리로 이동합니다.

mkdir bitcoin_data cd bitcoin_data

현재 디렉토리 경로를 확인 후 나온 경로를 메모에 복사해 둡니다.

pwd

### 4. 비트코인 설정 파일 생성 및 테스트넷 모드 설정
`bitcoin.conf` 파일을 생성하고 테스트넷 모드로 설정합니다.

vim bitcoin.conf

아래 내용을 입력한 후 저장합니다:

regtest=1 server=1 rpcuser=user rpcpassword=password datadir=(pwd 후 나온 경로를 붙여넣기) fallbackfee=0.0002

- `rpcuser`와 `rpcpassword`는 나중에 `bitcoin-cli`에서 인증에 사용됩니다.

### 5. 로컬 비트코인 네트워크 실행
새로운 터미널을 열고 로컬 비트코인 네트워크를 실행합니다.

bitcoind -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf

### 6. 블록체인 동기화 확인
기존 터미널에서 실행을 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getblockchaininfo

출력 결과에 `"chain": "regtest"`가 포함되어 있어야 합니다.

- `"blocks"`: 노드가 블록체인에서 다운로드 받은 블록 수
- `"headers"`: 네트워크에서 사용 가능한 최신 블록 헤더 수
- `"verificationprogress"`: 네트워크와 동기화 진행률
예: `"verificationprogress": 0.0001` → 동기화 초기 단계.
예: `"verificationprogress": 1` → 동기화 완료.

### 7. 테스트넷용 지갑 주소 생성
테스트넷용 지갑 주소를 생성합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf createwallet "(이름)"

### 8. 지갑 주소 확인
생성된 지갑 주소를 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getnewaddress

생성된 지갑 주소는 다른 곳에 복사해 놓습니다.

### 9. 지갑 잔액 확인
생성된 비트코인 지갑의 잔액을 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getbalance

### 10. 블록 채굴
채굴 명령어를 실행하여 블록을 생성합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf generatetoaddress 101 (복사한 지갑 주소)

101은 생성할 블록 수입니다. `101`개의 블록을 채굴해야 하는 이유는 비트코인 프로토콜에서 새로 생성된 코인을 바로 사용할 수 없도록 제한하기 때문입니다. 이는 체인 리오르그를 방지하고 네트워크 안정성을 높이는 역할을 합니다.

### 11. 블록 생성 후 잔액 확인
블록 생성 후 잔액을 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getbalance

### 12. 사용 가능한 UTXO 확인
사용 가능한 UTXO를 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf listunspent

### 13. 송금용 지갑 주소 생성
송금용 지갑 주소를 생성합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getnewaddress

내 주소들을 확인하려면 다음 명령어를 사용합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf listreceivedbyaddress 0 true

### 14. 비트코인 송금
새로 생성한 주소로 비트코인을 송금합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf sendtoaddress <받는 주소> <금액>

### 15. 트랜잭션 상태 확인
트랜잭션 상태를 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf gettransaction (트랜잭션 ID)

### 16. 트랜잭션 확정을 위해 블록 생성
트랜잭션 확정을 위해 추가 블록을 생성합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf generatetoaddress 10 (지갑 주소)

### 17. 트랜잭션 상태 재확인
블록 생성 후 트랜잭션 상태를 다시 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf gettransaction (트랜잭션 ID)

### 18. 마지막으로 지갑 잔고 확인
내 지갑 잔고를 확인합니다.

bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf listreceivedbyaddress 0 true

- `listreceivedbyaddress` 명령어는 특정 주소가 받은 비트코인의 총합을 표시하며, 입금된 코인의 총합만 보여주고 출금된 코인은 포함되지 않습니다.
- 출금된 트랜잭션을 확인하려면 `listtransactions` 명령어를 사용해야 합니다.

---
# 2025년 2월 6일 TIL

## 오늘 한 일

### 중앙 집중형 원장
- **장점**
  - **속도**: 데이터 처리 속도가 빠르며, 중앙 서버에서 모든 거래를 처리하므로 효율적
  - **관리 용이**: 하나의 중앙 기관에서 데이터 및 시스템을 관리하므로 수정 및 업데이트가 용이
  
- **단점**
  - **중앙화**: 하나의 중앙 기관에 의존하므로 해킹이나 장애 시 시스템 전체가 영향을 받을 수 있다
  - **보안 리스크**: 데이터가 한 곳에 집중되므로 외부 공격에 취약
  - **신뢰 문제**: 사용자들이 중앙 기관을 신뢰해야 하며, 중립성을 보장하기 어렵다

---

### 분산원장
- **종류**
  - **퍼블릭 블록체인**: 누구나 참여 가능, 예) 비트코인, 이더리움
  - **프라이빗 블록체인**: 제한된 참가자만 참여 가능, 예) 기업 간 거래 시스템
  - **컨소시엄 블록체인**: 여러 조직이 공동으로 관리, 예) 은행 간 네트워크
  
- **장점**
  - **보안성**: 데이터를 여러 곳에 분산시켜 중앙화된 공격에 강하다
  - **투명성**: 거래 내역이 공개되어 신뢰성 높다
  - **탈중앙화**: 특정 기관이나 개인에 의존하지 않는다

- **단점**
  - **속도**: 분산 처리로 인해 처리 속도가 느려질 수 있다
  - **자원 소모**: 분산 시스템에서의 자원 소모가 크고, 네트워크 유지비용이 높을 수 있다
  - **복잡성**: 시스템 설정과 유지가 복잡하며, 기술적 요구사항이 높다

- **분산 원장 핵심 기술**

    - **합의 알고리즘**: 네트워크의 모든 노드가 데이터의 유효성과 순서를 검증하고, 동일한 기록을 유지하기 위해 사용하는 방식 (ex PoW, PoS)
    - **암호화**: 데이터의 기밀성, 무결성, 그리고 사용자 신원을 인증
    - **노드 동기화**: 모든 노드가 동일한 데이터를 유지하도록 동기화 과정 진행

* 분산 원장 기술이 블록체인보다 더욱 큰 범위이다

---
### 노드의 정의
  - **노드**는 분산 네트워크에서 서버나 컴퓨터와 같은 장치
  - 각각의 **노드**는 네트워크 내에서 하나의 독립된 단위로 기능을 수행
    - 데이터 저장 및 검증, 네트워크 연결 및 데이터 전파, 합의 참여

### 풀 노드 (Full Node)
- **역할**: 블록체인의 전체 데이터를 저장하고, 모든 거래와 블록을 검증
- **특징**: 전체 블록체인 데이터를 보유하여 독립적으로 네트워크를 검증하고 유지

### 라이트 노드 / SPV 노드 (Light Node / SPV Node)
- **역할**: 전체 블록체인 데이터를 저장하지 않고, 필요한 최소 정보만 저장하여 네트워크에 참여
- **특징**: 트랜잭션 검증 시 블록 헤더만 사용하고, 다른 노드에 의존해 정보를 받아온다

### 마이닝 노드 (Mining Node)
- **역할**: 새로운 블록을 생성하고 네트워크에 추가하는 역할을 하는 노드
- **특징**: Proof of Work(PoW)와 같은 합의 알고리즘을 사용하여 블록을 생성하고 보상을 받는다

### 알트 코인에서 볼 수 있는 노드
- 알트코인은 네트워크의 목적과 기술적 요구에 따라 노드의 역할을 세분화하였다
  
- **검증 노드**
    - 주로 PoS기반 블록체인에서 사용
- **아카이브 노드**
    - 주로 스마트 컨트랙트가 실행되는 블록체인에서 사용
 
---
### 블록이 생성되는 과정

1. **트랜잭션 생성**
   - 사용자가 트랜잭션을 생성하여 네트워크에 제출

2. **브로드캐스트**
   - 트랜잭션이 네트워크 노드들에게 브로드캐스트된다
   - **브로드캐스트**: 트랜잭션 또는 블록이 새로 생기면 유효성 검사 후 다른 노드에 전파

3. **메모리 풀에 저장**
   - 마이닝 노드들이 브로드캐스트된 유효한 트랜잭션을 수집하여 **메모리 풀**에 저장
   - **메모리 풀**: 아직 블록에 포함되지 않은 미확인 트랜잭션들의 집합

4. **블록 템플릿 생성**
   - 마이닝 노드가 메모리 풀에서 트랜잭션을 선택하여 블록 템플릿을 생성

5. **PoW 수행**
   - 마이닝 노드가 블록 헤더에 대해 **PoW**를 수행
   - 목표: 블록 헤더의 해시값이 네트워크에서 요구하는 난이도 목표 이하의 값이 되도록 논스 값을 변경하여 반복적으로 해시를 계산

6. **블록 채굴**
   - 마이닝 노드가 유효한 해시값을 찾으면 블록이 채굴(생성)된다

7. **새 블록 브로드캐스트**
   - 새로 생성된 블록이 네트워크에 브로드캐스트된다

8. **블록 검증**
   - 다른 노드들이 새 블록의 유효성을 검증

9. **블록체인에 추가**
   - 검증된 블록은 블록체인에 추가됨
   - 블록체인은 이전 블록의 해시와 새 블록이 연결된 형태로 유지된다

10. **채굴 보상**
    - 채굴에 성공한 마이닝 노드는 **코인베이스 트랜잭션**을 통해 보상받는다
    - **코인베이스 트랜잭션**: 채굴 보상 + 거래 수수료

11. **가장 긴 체인 신뢰**
    - 네트워크는 가장 긴 체인을 신뢰하며, 다음 블록을 채굴하기 위한 작업을 반복한다


### 비잔틴 장애 허용(BFT, Byzantine Fault Tolerance)
- BFT는 분산 시스템에서 잘못된 정보나 부정한 행동을 하는 노드(즉, 악의적인 노드)가 존재할 때, 시스템이 여전히 신뢰성 있고 일관된 상태로 운영될 수 있도록 보장하는 메커니즘 (합의 알고리즘 PoW, PoS, DPoS)


### 합의 알고리즘의 대표적인 예시

#### 1. **PoW (Proof of Work)**:
- **설명**: 작업 증명 알고리즘으로, 블록을 생성하려는 노드는 수학적 문제를 해결해야 한다
- **특징**
  - 채굴자가 복잡한 계산을 통해 문제를 풀고, 그 결과로 새로운 블록을 추가
  - 계산 작업에 **많은 에너지와 자원**이 소모된다
  - **비트코인**, **이더리움(현재 PoW)** 등에서 사용

#### 2. **PoS (Proof of Stake)**
- **설명**: 지분 증명 알고리즘으로, 블록 생성자는 일정량의 코인을 보유하고 있을수록 블록 생성 확률이 높아진다
- **특징**
  - 블록 생성자 선정이 **지분(코인 보유량)**에 따라 결정된다
  - **에너지 효율적**이며, **속도와 확장성**이 더 뛰어난 경우가 많다
  - **이더리움 2.0**, **카르다노**, **폴카닷** 등에서 사용

#### 3. **DPoS (Delegated Proof of Stake)**
- **설명**: 위임 지분 증명 알고리즘으로, 네트워크 참가자들이 **대표자**를 선출하여 블록을 생성하고 합의에 참여
- **특징**
  - **빠른 블록 생성**과 **높은 확장성**을 제공
  - **대표자**가 블록을 생성하므로, **거래 처리 속도**가 매우 빠르다
  - **스팀**, **EOS**, **트론** 등에서 사용


### PoW 작동방식

1. 트랜잭션 모으기
2. 퍼즐 문제 해결
3. 블록 검증
4. 보상 지급


### 체인 분기 이유

1. **두 명 이상의 채굴자가 동시에 블록을 생성**
   - 동시에 두 개의 블록이 생성되어 네트워크에 전파될 경우 체인 분기가 발생

2. **네트워크 지연**
   - 일부 노드가 먼저 특정 블록을 수신하고, 다른 블록은 뒤늦게 수신되어 분기가 발생


### 체인 분기 후 결과

3. **체인 리오르그**
   - 분기된 체인 중 가장 긴 체인에 기존 체인이 이어지며, 이전 체인이 업데이트된다

4. **고아 블록**
   - 짧은 체인의 블록들은 무효화되고, 버려지는 블록

  
### PoS 보안 강화 방법: Nothing at Stake 문제

#### **Nothing at Stake**
- PoS에서 검증자가 블록을 생성할 때 자신이 보유한 코인에 비례한 지분을 사용하며, 블록을 두 개 이상 생성하거나 다중 체인을 만드는 것에 대한 비용이 없을 경우, 검증자가 두 개 이상의 블록에 동시에 투표할 수 있어 두 개의 체인이 동시에 존재할 수 있는 문제


#### 해결 방법

- **경제적 패널티 (Slashing)**
   - 검증자가 여러 체인에 서명하는 경우, 네트워크가 스테이킹된 자산을 몰수하여 페널티를 부여

- **체인 선택 규칙**
   - PoW와 마찬가지로 가장 긴 체인만 유효한 체인으로 간주

- **검증자가 한 체인에만 서명하도록 보상 설계**
   - 수수료와 벌금을 활용해 검증자가 한 체인에만 서명하도록 유도

- **검증자 서명 공개**
   - 검증자의 서명 데이터를 투명하게 공개하여 네트워크가 이중 서명을 쉽게 감지할 수 있도록 설계
 
### DPoS의 보안

- **대표자 교체**
   - 대표자가 부정행위를 하거나 네트워크 기여도가 낮으면, 사용자가 투표를 통해 다른 대표자로 교체

- **경제적 인센티브**
   - 대표자는 네트워크 운영의 대가로 보상을 받지만, 부정행위 시 신뢰를 잃고 보상을 받지 못한다 (Slashing)

- **투명성**
   - 모든 대표자의 행동은 네트워크에 기록되며, 사용자들이 이를 평가하고 판단할 수 있다


### **합의 알고리즘 정리 표**

| **특징**               | **PoW (Proof of Work)**                                   | **PoS (Proof of Stake)**                                     | **DPoS (Delegated Proof of Stake)**                           |
|------------------------|----------------------------------------------------------|--------------------------------------------------------------|--------------------------------------------------------------|
| **합의 방식**           | **작업 증명**: 계산 작업(해시값 계산)을 통해 블록을 생성 | **지분 증명**: 코인의 보유량에 비례하여 블록 생성 권한 부여 | **위임 지분 증명**: 사용자들이 대표자를 선출하여 블록 생성     |
| **에너지 소비**         | 매우 높음: 계산 작업이 많고 에너지 소모가 큼            | 낮음: 코인의 소유량에 따라 결정되므로 계산 작업이 적음        | 낮음: 위임된 대표자들이 블록 생성, 일반 사용자들은 참여하지 않음 |
| **블록 생성 기준**      | **해시값을 맞추는 작업**: 채굴자가 목표값을 맞추는 방식    | **지분**: 자신이 보유한 코인의 양에 비례하여 블록을 생성      | **위임된 대표자**: 선출된 대표자가 블록을 생성               |
| **검증자 선택 방법**    | **작업 증명**: 목표 해시를 맞추는 채굴자가 블록을 생성      | **지분 증명**: 보유한 코인의 양에 따라 블록 생성 권한이 결정 | **위임 지분 증명**: 사용자들이 대표자를 선출하여 검증자 역할을 부여 |
| **하드웨어 의존성**     | 높음: 고성능 컴퓨팅 파워가 필요, 전문 채굴 하드웨어 사용 | 낮음: 일반적인 컴퓨터와 소프트웨어로 참여 가능               | 낮음: 대표자만 고성능 하드웨어를 사용하고, 사용자는 참여만      |
| **확장성**              | 낮음: 작업 증명에 시간과 자원이 많이 들며 트랜잭션 속도가 느림 | 높음: 거래 속도가 빠르며 트랜잭션 처리 용량이 크다           | 매우 높음: 대표자가 관리하므로 더 빠르고 효율적인 트랜잭션 처리 |
| **중앙화 위험**         | 높음: 많은 계산력을 가진 채굴자가 시장을 지배할 가능성    | 낮음: 지분에 따라 블록 생성 권한이 분배되므로 중앙화가 적음  | 높음: 제한된 수의 대표자가 블록을 생성하므로 집중화될 위험 있음 |

---
### 채굴 (Mining)
- **설명**: 새로운 블록을 생성하기 위해 복잡한 수학적 문제를 해결하는 과정
- **주요 역할**: 블록체인 네트워크에 새로운 블록을 추가하고, 거래를 검증한다
- **기술적 특성**: Proof of Work(PoW) 등의 합의 알고리즘을 사용

### 마이닝 풀 (Mining Pool)
- **설명**: 여러 채굴자가 자원을 합쳐 협력적으로 블록을 채굴하는 네트워크
- **주요 역할**: 채굴자의 계산 능력을 모아 블록을 빠르게 채굴하고, 보상을 참여 비율에 맞춰 나눈다
- **기술적 특성**: 각 채굴자는 보상에서 일정 부분만 받지만, 개별 채굴자보다 더 높은 확률로 블록을 채굴할 수 있다

### 해시파워 (Hash Power)
- **설명**: 블록체인 네트워크에서 채굴자가 계산을 통해 문제를 푸는 능력을 나타내는 지표
- **역할**: 해시파워가 높을수록 블록을 찾을 확률이 높아지고, 더 많은 거래를 처리할 수 있다
- **중요성**: 네트워크의 보안과 속도에 영향을 미치며, 해시파워가 집중되면 중앙화와 보안 위협이 발생할 수 있다

  ### 채굴 풀의 위험성

- **중앙화 위험**
   - 많은 채굴력이 일부 풀에 집중되면 네트워크의 중앙화가 발생할 수 있으며, 이는 보안 및 신뢰성에 문제를 일으킬 수 있다
- **51% 공격**
   - 특정 채굴 풀이 전체 네트워크의 51% 이상의 해시 파워를 차지할 경우, 공격자가 블록체인에 대한 통제를 가질 위험이 있다
- **보상 분배 불공정**
   - 채굴 풀 내에서 보상이 불공정하게 분배될 경우, 일부 채굴자들은 기대한 보상을 받지 못할 수 있다
- **풀 운영자의 악의적 행위**
   - 풀 운영자가 부정 행위를 하거나, 수익을 공정하게 분배하지 않을 가능성이 있다

---

# 2025년 2월 7일 TIL

## 오늘 한 일

### 이더리움과 비트코인의 차이점: 튜링 완전성과 스마트 계약

#### 1. 이더리움의 탄생 배경
- 비탈릭 부테린은 비트코인이 디지털 화폐로만 사용되는 것에 아쉬움을 느껴 이더리움을 개발
- 비트코인의 한계:
  - 디지털 화폐로만 사용됨
  - 비트코인의 스크립트 언어는 기능이 제한적
  - 복잡한 스마트 계약이나 애플리케이션을 실행하기 부족하다

#### 2. 튜링 완전성 (Turing Completeness)
- 튜링 완전성: 적절한 알고리즘과 충분한 리소스를 주어진다면, 어떤 계산 가능한 문제도 해결할 수 있는 능력
  
##### 튜링 기계
- 엘런 튜링이 제안한 가상의 계산 모델로, 현대 컴퓨터의 계산 가능성을 설명하는 기초가 되는 개념
- 튜링 기계의 구성 요소:
  - 무한한 테이프: 데이터 저장소 역할
  - 읽기/쓰기 헤드: 데이터를 읽고 쓸 수 있다
  - 상태 머신: 현재 상태와 입력에 따라 동작을 결정하는 규칙 집합

- 튜링 완전성을 갖추기 위한 조건:
  1. 조건 분기 (Conditional Branching): If-Else와 같은 조건문을 처리할 수 있어야 한다
  2. 임의의 루프 (Arbitrary Loops): While, For 루프처럼 반복 실행이 가능해야 한다

#### 3. 튜링 완전성과 예시
- **튜링 완전한 시스템**:
  - 프로그래밍 언어: Python, Java, C++, JavaScript 등 대부분의 일반 프로그래밍 언어
  - 스마트 계약 플랫폼: 이더리움의 Solidity 언어는 튜링 완전성을 가진다
    - 복잡한 계산과 조건 논리 수행 가능
    - 튜링 완전성은 스마트 계약과 관련하여 중요한 개념
    - 스마트 계약 플랫폼에서 튜링 완전성을 지원하면 복잡한 로직을 실행할 수 있다
    - 동시에 보안 문제와 무한 로프같은 자원 낭비가 발생할 가능성도 존재
  
- **튜링 불완전한 시스템**:
  - SQL: 데이터베이스 쿼리 언어로 무한 반복을 지원하지 않는다
  - 비트코인 스크립트: 트랜잭션 스크립트 언어로 튜링 불완전
    - 조건 분기와 루프 제한 → 보안 강화와 복잡성 축소

#### 4. 튜링 완전성과 스마트 계약
- **이더리움**:
  - **EVM (Ethereum Virtual Machine)**: 튜링 완전성 지원
  - 복잡한 스마트 계약 실행 가능
  - **가스 제한 (Gas Limit)**: 튜링 안전성으로 인한 무한 루프 방지
  
- **비트코인**:
  - **스크립트 언어**는 튜링 불완전
  - **단순한 트랜잭션 처리**에 초점, 보안을 높이기 위해 설계된다

### 튜링 완전성의 장단점

##### 장점
- 복잡한 로직 구현 가능
- 다양한 계산 및 문제 해결 가능
- 스마트 계약 개발 및 자동화 작업 지원

##### 단점
- 무한 루프 또는 자원 낭비 발생 가능
- 보안 취약점 발생 가능
- 실행 시간이 예측 불가능할 수 있음

### 비트코인과 이더리움의 설계 목적과 차이점

##### 비트코인
- 디지털 통화(가치 저장 및 거래), 단순하고 안정적인 설계

##### 이더리움
- 스마트 계약 및 탈중앙화 애플리케이션 실행
- 유연하고 확장 가능한 설계

### 비트코인과 이더리움의 주소 차이

- **공통점**: 둘 모두 ECDSA(secp256k1) 알고리즘을 사용

- **차이점**
    - **비트코인**:
      - 해시 함수: SHA-256 + RIPEMD-160
      - Base58 인코딩 방식, 숫자와 문자 조합
    - **이더리움**:
      - 해시 함수: keccak-256
      - 16진수(40자), "0x"로 시작

### 블록체인 모델 차이

#### 이더리움: 어카운트 기반 모델 (Account-based)
- 계정 모델을 사용하여 모든 사용자와 스마트 계약을 계정으로 표현
- 계정 종류:
  1. **외부 소유 계정 (EOA)**:
     - 개인이 소유한 계정, 비공개 키로 제어, 트랜잭션 생성 가능
     - 사람이 사용하는 계정으로 프라이빗 키가 있다
  4. **스마트 계약 계정 (Contract Account)**:
     - 스마트 계약이 배포된 계정, 트랜잭션 발생 시 코드 실행, 트랜잭션 생성 불가
     - 프라이빗키가 없으므로 트랜잭션을 생성할 수 없다
     - 하지만 EOA가 요청할 시 조건이 충족되면 CA가 생성할 수 있는 트랜잭션이 있다
        - 계정 상태:
          - Nonce: 계정에서 보낸 트랜잭션의 횟수
          - Balance: 계정에 저장된 이더(ETH)의 양
          - Storage: 스마트 계약 데이터 (스마트 계약 계정에만 해당)
          - CodeHash: 스마트 계약 코드 (스마트 계약 계정에만 해당)

#### 비트코인: UTXO 기반 모델
- UTXO(미사용된 출력값) 모델을 사용하여 트랜잭션을 관리

### Nonce 사용

#### 비트코인에서의 Nonce
- **PoW의 채굴 과정**에서 사용
- 32비트 정수로 표현되며 해시 결과를 생성하는 변수로 사용
- 채굴자는 해시값을 맞추기 위해 추가적인 해시 시도를 진행

#### 이더리움에서의 Nonce
- 계정 기반 모델에서 트랜잭션 순서 관리 및 고유 식별자 역할
- **트랜잭션 순서 관리**: 각 계정에 Nonce값이 있으며 이는 계정에서 발생한 트랜잭션의 수를 나타낸다
- **재사용 방지**: 동일한 Nonce값을 사용하는 트랜잭션은 네트워크에서 거부되어 재생 공격을 방지
- **병렬 트랜잭션 처리**: 여러 트랜잭션이 동시에 발생할 때, Nonce는 트랜잭션 순서를 결정하는 데 사용

### 이더리움의 보안 및 재생 공격 방지

#### 재생 공격 (Replay Attack)
- 트랜잭션 데이터를 복사하여 다른 네트워크나 상황에서 다시 실행하는 공격 방식

#### 재생 공격 주요 사례: 하드포크 (Hard Fork)
- 하드포크 : 블록체인 기술에서 기존 프로토콜을 변경하거나 업데이트하여 이전 버전과 호환되지 않는 새로운 체인을 생성하는 과정을 의미
- 하드포크 후 두 체인에서 동일한 트랜잭션 데이터가 유효할 경우, 동일한 트랜잭션이 두 네트워크에서 실행될 수 있다
    - 예: 이더리움 클래식에서 발생한 트랜잭션이 이더리움에서도 실행될 수 있다

#### 비트코인에서의 이중 지불 방지
- **UTXO 모델**을 통해 미사용된 출력값을 관리하여 이중 지불을 방지

#### 이더리움에서의 이중 지불 방지
- 각 트랜잭션에 고유한 Nonce를 부여하는 **Nonce값**을 통해 트랜잭션의 고유성을 관리하고 재생 공격을 방지

#### 이더리움에서 재생 공격 방지
- **Nonce 사용**: 이더리움에서는 각 트랜잭션에 고유한 Nonce를 부여하여 동일한 트랜잭션이 다시 실행되지 않도록 한다
- **체인 ID**: 포크된 체인에서는 체인 ID를 도입하여 각 체인을 구분하고 재생 공격을 방지 (예: 이더리움과 이더리움 클래식은 서로 다른 체인 ID 사용)
   - EIP-155는 체인 ID를 포함하여 이더리움의 재생 공격을 방지하는 방안을 제시
  


#### 이더리움과 비트코인
- 비트코인과 이더리움은 설계 목적이 달라 기술적 구조와 작동방식에서 차이가 있다
- 둘 모두 방지 방법은 합의 알고리즘이다
- **비트코인**은 디지털 통화에 초점을 맞추고, **이더리움**은 스마트 계약 및 탈중앙화 애플리케이션 실행에 중점을 둔다

---

### 이더리움과 비트코인: 프로그래밍 및 가상 머신

#### 프로그래밍 가능성
- **비트코인**:
  - 비트코인은 **간단한 스크립트**를 통해 **기본적인 트랜잭션 논리만 처리**
  - 별도의 **가상 머신** 없이 **거래 데이터만 처리**
  
- **이더리움**:
  - **Solidity**와 같은 **튜링 완전한 언어**를 사용하여 **복잡한 로직을 구현**
  - **스마트 계약**은 자동화된 프로세스를 구현하며, 탈중앙화 애플리케이션(DApp)의 기반을 제공

#### 가상 머신 (Virtual Machine)
- **비트코인**:
  - **가상 머신**이 없으며, 거래의 데이터만 처리
  - 기본적인 트랜잭션 논리만 수행
  
- **이더리움**:
  - **EVM**은 **스마트 계약**을 실행하는 **추상화된 소프트웨어 환경**
  - 실제 하드웨어에서 실행되지 않으며, 이더리움 네트워크에서 스마트 계약과 그 상태 변화를 처리

#### EVM의 동작 방식
- **EVM**:
  - **Solidity** 같은 고급 언어를 **바이트코드로 컴파일**하지만, 실행은 **인터프리터 방식**으로 처리
  - **트랜잭션을 처리**하며, **스마트 계약의 상태 변화를 관리**
  - 이더리움에서는 동적 실행환경에서 상태가 변할 때마다 계산을 실시간으로 처리해야 하므로 인터프리터 방식이 유리

#### 왜 컴파일과 인터프리터를 모두 사용하는가?
- **컴파일**:
  - 성능 최적화가 가능하고, **바이트코드로 최적화된 실행을 준비**할 수 있다
  
- **인터프리터**:
  - 동적 환경에서 **실시간으로 상태 변화에 맞는 계산을 처리**할 수 있다
  - **가스 시스템**에 적합하며, 연산 비용을 추적하고 **무한 루프** 등의 자원 낭비를 방지

#### EVM의 아키텍처
- **스택 기반 아키텍처**로 실행되며, 모든 연산은 **스택**을 이용해 처리
- 명령어는 **Opcode**로 해석되며, **스택**을 통해 계산과 상태 관리가 이루어진다

#### 스마트 계약의 보안
- 이더리움은 **튜링 완전**한 프로그래밍을 지원하지만, **무한 루프**와 **과도한 연산** 위험이 존재
- 이를 방지하기 위해 **가스 비용**을 부과하고, **가스가 소진되면 트랜잭션이 중단**

---

### 스마트 컨트랙트 및 EVM의 보안과 효율성

#### 보안격리 (Sandboxing)
- **EVM**은 스마트 계약 간의 충돌을 방지하기 위해 **격리된 실행 환경**을 제공
- 잘못된 코드나 의도치 않은 행동이 **네트워크**나 다른 계약에 영향을 미치지 않도록 보장
- 이를 통해 블록체인의 **안정성**과 **보안성**이 강화됩니다

#### 가스 (Gas)
- **가스**는 **바이트코드 실행** 시 소모되는 비용을 의미
- 네트워크 자원 낭비를 방지하고 **효율성**을 유지하기 위한 중요한 메커니즘
- 스마트 계약이 실행될 때마다 **가스 비용**이 소모되며, 이는 네트워크에서의 연산 자원을 효율적으로 관리

#### 스마트 컨트랙트
- **스마트 컨트랙트**는 블록체인 네트워크에서 **호스팅**되고 실행되는 **자동화된 계약**이다
- 일정 조건이 충족되면 **자동으로 계약을 이행**하도록 설계된다
- 기존의 **서면 계약**의 복잡한 검증과 실행 과정을 디지털화하여, 스마트 컨트랙트를 통해 **빠르고 정확하게 계약을 이행**할 수 있다

#### 스마트 컨트랙트의 특징
- 스마트 컨트랙트는 **탈중앙화된 블록체인 네트워크**에서 실행되며, **중앙 서버** 없이 계약이 자동으로 이행된다
- **블록체인의 분산 구조**와 **암호화 기술** 덕분에 계약 조건이나 이행 내용을 변조하기 어렵고, **제3자 중개자**의 개입 없이 신뢰를 제공한다

#### 스마트 컨트랙트의 개념
- **닉 재보**(Nick Szabo)는 1994년 **스마트 컨트랙트**라는 개념을 제안했다
  - "계약 조건을 실행하는 전산화된 트랜잭션 프로토콜"을 정의하였으며, 이를 통해 **악의적**이거나 **우발적인 예외**를 최소화하고 **중개자의 필요성**을 줄이는 것을 목표로 했다

- **비트골드**는 닉 재보가 제안한 스마트 컨트랙트 기반의 디지털 화폐이지만, **기술적 한계**로 인해 실제 구현되지 못했다

### 스마트 컨트랙트 개요

#### 스마트 컨트랙트를 처음으로 지원한 화폐 - 비트코인
- **비트코인**은 **스크립트 언어**를 사용하여 화폐 거래와 관련된 특정 로직을 설정할 수 있다
- 하지만 **비트코인**은 본질적으로 **전자화폐 중심** 시스템이므로 **제한적인 프로그래밍**만 가능하다

#### 이더리움과 스마트 컨트랙트
- **비탈릭 부테린**은 **이더리움**을 개발하여 **Solidity** 언어를 통해 **스마트 컨트랙트**를 작성할 수 있게 했다
- **EVM (Ethereum Virtual Machine)**을 통해 이더리움 블록체인 위에서 **스마트 컨트랙트 코드**를 실행할 수 있다
- 이를 통해 **이더리움**은 여러 개의 **독립적인 스마트 컨트랙트**를 동시에 실행할 수 있어 **"월드 컴퓨터"**라고 불리기도 한다

#### 스마트 컨트랙트의 특징
- **조건 충족 시 자동 실행**: 스마트 컨트랙트는 **제3자**의 개입 없이 조건이 충족되면 자동으로 계약이 이행됩니다. 조건이 충족되지 않으면 이행되지 않는다
  - 예시: **모바일 게임의 자동 보상 시스템**처럼 조건에 맞는 보상이 자동으로 주어진다
  
- **배포 및 자동화 가능**: 스마트 컨트랙트는 **누구나 배포**할 수 있으며, **자유롭게 자동화**할 수 있다
  - **검증** 및 **제약**이 없고, 한번 배포된 후에는 **변경 불가능**

#### 전통적인 계약 방식과 스마트 컨트랙트의 차이점
- **전통적인 계약**에서는 거래를 보장하기 위해 **제3자** (예: 은행, 정부) 등의 신뢰할 수 있는 기관이 필요하다
  - 이를 통해 **많은 수수료**가 발생
  
- **스마트 컨트랙트**에서는 **코드**에 의해 계약이 실행되며, **변경 불가능**하고 **모두에게 공개**되므로, 제3자가 필요하지 않는다
  - 이로 인해 **거래 수수료**가 거의 발생하지 않는다

- 또한, **스마트 컨트랙트**는 블록체인에 올라가며 **네트워크에 참여한 누구든지** 이를 확인할 수 있기 때문에 **거래 내역이 투명**하게 공개

#### 스마트 컨트랙트의 동작 방식
- 스마트 컨트랙트는 조건이 충족되면 지정된 **액션**을 실행
  
  예시:
  ```plaintext
  If or when (이벤트 x가 실행되면)
  {
      액션 y를 실행하라
  }

#### 스마트 컨트랙트의 동작 원리

- 블록체인 네트워크에 스마트 컨트랙트가 올라가면, **미리 설정된 조건**이 충족되고 **검증된 경우**, **조건에 따른 액션**을 실행
- 이 **액션**은 **트랜잭션**에 기록되고, 완료된 트랜잭션은 **블록체인에 올라간다**

#### 스마트 컨트랙트의 특성

- 스마트 컨트랙트는 **조건에 따른 결과**가 **미리 결정**
- 즉, 스마트 컨트랙트의 결과는 **확률적인 상태**가 아니라 **결정론적인 상태**이다
- 스마트 컨트랙트는 **다자간 디지털 계약**으로서, 조건을 만족하는 **코드에 의해 자동으로 실행**


### 스마트 컨트랙트의 장점

#### 보안
- 스마트 컨트랙트는 **분산형 블록체인** 인프라 위에서 실행
- 스마트 컨트랙트 코드가 블록체인 네트워크에 올라가면 모든 노드가 코드와 이행 결과를 가지게 되어 **중앙화된 공격 지점**이 없다
- 따라서 계약 내용이나 결과를 **변조할 위험**이 없다

#### 신뢰성
- 스마트 컨트랙트 로직이 조건에 맞게 계약을 이행하면 **블록체인 네트워크**의 노드들에 의해 여러 번 수행되고 검증되므로 **위변조**가 어렵고, **신뢰성이 높다**

#### 공평함
- 계약 조건을 **분산화된 블록체인**을 통해 공유하고 검증하므로, **중앙화된 제3자**가 필요하지 않으며, 거래 시 발생하는 **수수료**가 없다

#### 효율성
- 계약 이행을 **자동화**하여, 계약 당사자들이 **수동으로 데이터를 입력하거나 계약 의무 이행 여부를 검증**하는 불필요한 작업을 줄일 수 있다
  

### 스마트 컨트랙트의 한계점

#### 배포 후 수정 불가
- 스마트 컨트랙트는 **배포 후 작동 수정이 불가능**
- 보안 허점 발견 시, 수정이 어려워 해킹에 취약할 수 있다. 이를 해결하기 위한 **프록시 패턴**과 같은 방법이 있지만, 완벽한 해결책은 아니다

#### 블록체인 외 정보 활용 불가
- 스마트 컨트랙트는 **블록체인 외부의 데이터**를 직접적으로 얻을 수 없다
- 외부 데이터를 활용하기 위해 **오라클**을 사용해야 하지만, **오라클의 데이터**가 신뢰할 수 있는지, 오류가 발생하지 않는지 확인해야 한다. 악의적인 데이터 입력 시 **계약이 의도하지 않은 방식**으로 실행될 위험이 존재한다

---

### 실습: 메타마스크와 EVM 계열 블록체인 테스트

#### 1 메타마스크 설치
- **메타마스크**를 구글에서 확장 프로그램으로 설치
- 설치 후, **지갑 생성**을 선택

#### 2 지갑 생성
- **내 지갑 보호**를 위해 복구 구문을 가져온다
- 생성된 **복구 구문**을 빈 칸에 기입하여 지갑 생성을 완료

#### 3 EVM 계열 블록체인 노드 연결
- 지갑은 특정 노드의 **RPC URL**을 이용하여 블록체인에 저장된 온체인 데이터를 요청

#### 3.1 사용자 지정 네트워크 추가
1. 좌측에서 **사용자 지정 네트워크**를 추가
2. 아래 정보를 입력하여 새로운 네트워크를 추가
   - **네트워크 이름**: Kaia Kairos Testnet
   - **기본 RPC URL**: https://public-en-kairos.node.kaia.io
   - **체인 ID**: 1001
   - **통화 기호**: KAIA
   - **블록 탐색기 URL**: https://kairos.kaiascan.io/

#### 4 Faucet을 이용하여 테스트용 코인 받기
1. 추가된 네트워크로 변경
2. 테스트용 소량의 코인을 받기 위해 [Kaia Faucet](https://www.kaia.io/faucet)에 들어가서 자신의 주소를 입력하고 코인을 받는다
3. 메타마스크에서 **코인이 들어온 것을 확인**

#### 5 트랜잭션 전송
- **보내기** 버튼을 눌러 수신자의 주소를 입력하고 코인을 전송
  
#### 5.1 컨펌을 클릭하면 발생하는 일
1. **컨펌**을 클릭하면 트랜잭션 세부 정보가 사용자에게 명확하게 표시되고, 사용자는 승인을 진행
2. **개인 키**를 사용하여 트랜잭션에 **디지털 서명**을 처리
3. 서명된 트랜잭션이 **네트워크로 브로드캐스트**되어 처리
4. 네트워크가 트랜잭션을 처리하고 **블록에 포함**된 뒤 상태를 업데이트

#### 6 블록체인 익스플로러를 통한 거래 내역 확인
블록체인 익스플로러는 블록체인 네트워크에서 발생하는 트랜잭션, 블록, 계정, 스마트 계약 등을 조회할 수 있는 웹 기반 도구이다. 각 블록체인마다 자신만의 익스플로러를 운영하고 있다

1. [Kairos Blockchain Explorer](https://kairos.kaiascan.io/)로 이동하여 방금 보낸 거래 내역을 확인
2. **자신의 주소**를 검색창에 입력하여 조회
3. **Transactions 탭**으로 들어가면 트랜잭션 내역을 확인할 수 있다
4. **수신자 주소**가 맞는 **TX Hash (TxID)**를 클릭하여 전송 내역을 확인한다

---

  


